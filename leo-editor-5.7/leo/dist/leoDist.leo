<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20050315084904"><vh>Startup</vh>
<v t="ekr.20141117135127.2"><vh>@settings</vh>
<v t="ekr.20141117135127.3"><vh>@bool wikiview-active = False</vh></v>
</v>
<v t="ekr.20070325123540"><vh>@chapters</vh></v>
<v t="ekr.20101025095431.1517"><vh>Installer/Distribution bugs &amp; to-do</vh>
<v t="ekr.20101025095431.1518"><vh>Fixed Bug 514656 Uninstall operation does not work as expected</vh>
<v t="ekr.20090901092556.1576"><vh>genUninstallData &amp; helpers</vh>
<v t="ekr.20090901121423.1568"><vh>getDeleteDirectories</vh></v>
<v t="ekr.20090901121423.1569"><vh>getDeleteFiles</vh></v>
<v t="ekr.20090901121423.1567"><vh>getUninstallVariableData</vh></v>
</v>
</v>
<v t="ekr.20101026142031.1516"><vh>Registry Keys</vh></v>
</v>
<v t="ekr.20170911061827.1"><vh>@button check .leo files</vh>
<v t="ekr.20170911062209.1"><vh>&lt;&lt; define files &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20161024113526.1"><vh>Notes</vh>
<v t="ekr.20160501153808.1"><vh>Anaconda install notes</vh></v>
<v t="ekr.20161024113542.1"><vh>#106 Homebrew (MacOS) notes</vh>
<v t="ekr.20161025114444.1"><vh>The latest formula</vh></v>
<v t="ekr.20161025114433.1"><vh>Posts</vh>
<v t="ekr.20161024113553.1"><vh>Post 1: Winn Dixie</vh></v>
<v t="ekr.20161024113810.1"><vh>Post 2: ludwigschwardt</vh></v>
<v t="ekr.20161024114150.1"><vh>Post 3: me April 15, 2015</vh></v>
<v t="ekr.20161025091538.1"><vh>Post 4: me April 24, 2015</vh></v>
<v t="ekr.20161025091621.1"><vh>Post 5: ludwidswardt April 24, 2015</vh></v>
<v t="ekr.20161024115114.1"><vh>Post 4: me May 1, 2015</vh></v>
</v>
<v t="ekr.20161024115257.1"><vh>How to compute the sha256 hash</vh></v>
</v>
</v>
<v t="EKR.20040519091259"><vh>Announcements</vh>
<v t="EKR.20040519091259.1"><vh>Download statistics</vh></v>
<v t="ekr.20160315105606.1"><vh>Previous announcements</vh>
<v t="ekr.20160314155303.1"><vh>Leo 4.x</vh>
<v t="ekr.20101115090518.1494"><vh>Leo 4.8 final</vh></v>
<v t="ekr.20110603112852.1505"><vh>Leo 4.9 final</vh></v>
<v t="ekr.20120328150744.1791"><vh>Leo 4.10 final</vh></v>
<v t="ekr.20131105110107.16636"><vh>Leo 4.11 final</vh></v>
</v>
<v t="ekr.20141105082156.2"><vh>Leo 5.0 final</vh></v>
<v t="ekr.20150415145711.1"><vh>Leo 5.1 final</vh></v>
<v t="ekr.20160314155002.1"><vh>Leo 5.2-final</vh>
<v t="ekr.20160314155002.2"><vh> Highlights</vh></v>
<v t="ekr.20160314155002.3"><vh>Bugs</vh>
<v t="ekr.20160314155002.4"><vh>Fixed #131: Insert time in headline now inserts time in body</vh></v>
<v t="ekr.20160314155002.5"><vh>Fixed #136: Viewrendered2 chokes on displaying @html nodes</vh></v>
<v t="ekr.20160314155002.6"><vh>Fixed #150: Importing file to @clean produces section references...</vh></v>
<v t="ekr.20160314155002.7"><vh>Fixed #162: Valid language list in Docs not up to date</vh></v>
<v t="ekr.20160314155002.8"><vh>Fixed #169: import-file does not preserve gnx of root @file node</vh></v>
<v t="ekr.20160314155002.9"><vh>Fixed #181: Focus remains in previous file</vh></v>
<v t="ekr.20160314155002.10"><vh>Fixed #182: Long filenames do not wrap in notification dialogues</vh></v>
<v t="ekr.20160314155002.11"><vh>Fixed #193: goto-global-line doesn't work properly in @clean files</vh></v>
<v t="ekr.20160314155002.12"><vh>Fixed #195: fcol when using @first directive is inaccurate</vh></v>
<v t="ekr.20160314155002.13"><vh>Fixed #196: Traceback using graphcanvas.py</vh></v>
<v t="ekr.20160314155002.14"><vh>Fixed #198: Find tab 'ignore case' tick box has no effect</vh></v>
<v t="ekr.20160314155002.15"><vh>Fixed #199: The "already open" logic hard crashes Leo</vh></v>
<v t="ekr.20160314155002.16"><vh>Fixed #200: goto-global-line logic is too complex and buggy</vh></v>
<v t="ekr.20160314155002.17"><vh>Fixed #211: Saving untitled document on window close not working on Qt GUI</vh></v>
<v t="ekr.20160314155002.18"><vh>Fixed #213: leo --ipython fails to connect with python3.5 and jupyter</vh></v>
<v t="ekr.20160314155002.19"><vh>Fixed #215: insert-file-name doesn't process ~</vh></v>
<v t="ekr.20160314155002.20"><vh>Fixed #217: vim plugin does not work as described</vh></v>
<v t="ekr.20160314155002.21"><vh>Fixed #218: Select Text and Clipboard</vh></v>
<v t="ekr.20160314155002.22"><vh>Fixed #220: @spot bug</vh></v>
<v t="ekr.20160314155002.23"><vh>Fixed #224: TypeError: unorderable types...</vh></v>
<v t="ekr.20160314155002.24"><vh>Fixed #234: hard crash on UnicodeDecodeError</vh></v>
<v t="ekr.20160314155002.25"><vh>Fixed #239: cfa fails to find many occurrences...</vh></v>
<v t="ekr.20160314155002.26"><vh>Fixed @tabwidth bug</vh></v>
<v t="ekr.20160314155002.27"><vh>Fixed a bug in p.__eq__</vh></v>
<v t="ekr.20160314155002.28"><vh>Fixed abbreviation bugs and improved abbreviations</vh></v>
<v t="ekr.20160314155002.29"><vh>Fixed cut/paste from menus</vh></v>
<v t="ekr.20160314155002.30"><vh>Fixed Find crash</vh></v>
<v t="ekr.20160314155002.31"><vh>Fixed Python 3k problem with @lineending</vh></v>
<v t="ekr.20160314155002.32"><vh>Fixed remove-blank-lines command</vh></v>
<v t="ekr.20160314155002.33"><vh>Improved Ctrl-LtArrow</vh></v>
<v t="ekr.20160314155002.34"><vh>Investigated #153: Leo acts on some operator input when the Leo window is NOT the top window</vh></v>
<v t="ekr.20160314155002.35"><vh>Investigated #188: Find/Replace All Suboutline only same as Node only</vh></v>
<v t="ekr.20160314155002.36"><vh>Investigated #188: Find/Replace All Suboutline only same as Node only</vh></v>
<v t="ekr.20160314155002.37"><vh>Investigated #232: print-plugins-info fails</vh></v>
<v t="ekr.20160314155002.38"><vh>Recover from orphan bit in leoPyBad.leo</vh></v>
</v>
<v t="ekr.20160314155002.39"><vh>Code</vh>
<v t="ekr.20160314155002.40"><vh>Added new position predicates for limiting search</vh></v>
<v t="ekr.20160314155002.41"><vh>c.backup</vh></v>
<v t="ekr.20160314155002.42"><vh>c.cloneFindByPredicate</vh></v>
<v t="ekr.20160314155002.43"><vh>Changed handling of orphan bits</vh></v>
<v t="ekr.20160314155002.44"><vh>Decorators simplify Leo's command dispatching</vh></v>
<v t="ekr.20160314155002.45"><vh>Removed g.isChar</vh></v>
<v t="ekr.20160314155002.46"><vh>Reorganized Leo's commands files</vh></v>
<v t="ekr.20160314155002.47"><vh>Replace all has_key by "in"</vh></v>
<v t="ekr.20160314155002.48"><vh>Verified that c.p.copy() is always redundant</vh></v>
</v>
<v t="ekr.20160314155002.49"><vh>Commands</vh>
<v t="ekr.20160314155002.50"><vh>Alt-N (goto-next-clone) falls backs to find-next-clone</vh></v>
<v t="ekr.20160314155002.51"><vh>cfa and cff</vh></v>
<v t="ekr.20160314155002.52"><vh>cffm and cfam</vh></v>
<v t="ekr.20160314155002.53"><vh>clear-log</vh></v>
<v t="ekr.20160314155002.54"><vh>clone-to-at-spot</vh></v>
<v t="ekr.20160314155002.55"><vh>cut/copy</vh></v>
<v t="ekr.20160314155002.56"><vh>find-all now writes to the body of a new top-level node</vh></v>
<v t="ekr.20160314155002.57"><vh>find-def &amp; find-var</vh></v>
<v t="ekr.20160314155002.58"><vh>flatten-outline-to-node</vh></v>
<v t="ekr.20160314155002.59"><vh>help-for-keystroke</vh></v>
<v t="ekr.20160314155002.60"><vh>kill</vh></v>
<v t="ekr.20160314155002.61"><vh>show-invisibles uses Qt characters</vh></v>
<v t="ekr.20160314155002.62"><vh>vim-open-file command</vh></v>
</v>
<v t="ekr.20160314155002.63"><vh>Directives</vh>
<v t="ekr.20160314155002.64"><vh>@beautify and @nobeautify</vh></v>
<v t="ekr.20160314155002.65"><vh>@wrap now honored immediately</vh></v>
</v>
<v t="ekr.20160314155002.66"><vh>Features</vh>
<v t="ekr.20160314155002.67"><vh>Decluttered headlines</vh></v>
<v t="ekr.20160314155002.68"><vh>Abbreviations now support auto-close quotes</vh></v>
<v t="ekr.20160314155002.69"><vh>Added new Themes machinery</vh></v>
<v t="ekr.20160314155002.70"><vh>Allow wildcard expansion of filenames on the command-line</vh></v>
<v t="ekr.20160314155002.71"><vh>Ctrl-G now resets status line</vh></v>
<v t="ekr.20160314155002.72"><vh>Find commands now show status</vh></v>
<v t="ekr.20160314155002.73"><vh>Optional line numbers</vh></v>
<v t="ekr.20160314155002.74"><vh>Use Qt code to show invisibles</vh></v>
</v>
<v t="ekr.20160314155002.75"><vh>Menus</vh>
<v t="ekr.20160314155002.76"><vh>Settings: Edit Settings menu</vh></v>
<v t="ekr.20160314155002.77"><vh>File:Print menu</vh></v>
</v>
<v t="ekr.20160314155002.78"><vh>Plugins</vh>
<v t="ekr.20160314155002.79"><vh>leoOPML.py</vh></v>
<v t="ekr.20160314155002.80"><vh>mod_http.py: controlling Leo remotely</vh></v>
</v>
<v t="ekr.20160314155002.81"><vh>Scripts</vh>
<v t="ekr.20160314155002.82"><vh>make_stub_files.py</vh></v>
<v t="ekr.20160314155002.83"><vh>python_to_coffescript.py</vh></v>
</v>
<v t="ekr.20160314155002.84"><vh>Settings</vh>
<v t="ekr.20160314155002.85"><vh>@bool find-ignore-duplicates</vh></v>
<v t="ekr.20160314155002.86"><vh>@bool preload-find-pattern</vh></v>
<v t="ekr.20160314155002.87"><vh>@bool syntax-error-popup</vh></v>
<v t="ekr.20160314155002.88"><vh>@bool use_find_dialog</vh></v>
<v t="ekr.20160314155002.89"><vh>@color find-*</vh></v>
<v t="ekr.20160314155002.90"><vh>@data abbreviations-subst-env now allows Leo directives</vh></v>
<v t="ekr.20160314155002.91"><vh>@data history-list</vh></v>
<v t="ekr.20160314155002.92"><vh>@data qt-gui-user-style-sheet</vh></v>
<v t="ekr.20160314155002.93"><vh>@ifenv, improved @ifplatform &amp; @ifhostname</vh></v>
<v t="ekr.20160314155002.94"><vh>@language coffeescript</vh></v>
<v t="ekr.20160314155002.95"><vh>Settings for gutter numbers</vh></v>
</v>
</v>
<v t="ekr.20160428153901.1"><vh>Leo 5.3-final</vh></v>
<v t="ekr.20161015114905.1"><vh>Leo 5.4-final</vh></v>
<v t="ekr.20170316113823.1"><vh>Leo 5.5</vh>
<v t="ekr.20170316113823.2"><vh>Most important features</vh>
<v t="ekr.20170316113823.3"><vh>Fixed huge performance bug in syntax coloring</vh></v>
<v t="ekr.20170316113823.4"><vh>Optionally run pyflakes when saving files</vh></v>
<v t="ekr.20170316113823.5"><vh>Greatly improved javascript and perl importers</vh></v>
<v t="ekr.20170316113823.6"><vh>Optionally colorize doc parts using rST</vh></v>
<v t="ekr.20170316113823.7"><vh>#371: execute-script supports multiple @language direcitves</vh></v>
<v t="ekr.20170316113823.8"><vh>#334: Rewrote all of Leo's importers</vh></v>
<v t="ekr.20170316113823.9"><vh>#328: The pylint command now runs in the background</vh></v>
<v t="ekr.20170316113823.10"><vh>#311: Simplified Leo's argument logic</vh></v>
</v>
<v t="ekr.20170316113823.11"><vh>Bugs</vh>
<v t="ekr.20170316113823.12"><vh>#325: Simplify the organization of commands</vh></v>
<v t="ekr.20170316113823.13"><vh>#340: finish (for 5.5) reload-settings</vh></v>
<v t="ekr.20170316113823.14"><vh>#343: (unicode problems in file names)</vh></v>
<v t="ekr.20170316113823.15"><vh>#344: @string view-rendered-default-kind not functional</vh></v>
<v t="ekr.20170316113823.16"><vh>#348: (CDATA errors)</vh></v>
<v t="ekr.20170316113823.17"><vh>#350: themes not working as documented</vh></v>
<v t="ekr.20170316113823.18"><vh>#352: Importer unit tests create both @clean and @file</vh></v>
<v t="ekr.20170316113823.19"><vh>#367: goto-script problems</vh></v>
<v t="ekr.20170316113823.20"><vh>#371: support multiple languages in scripts</vh></v>
<v t="ekr.20170316113823.21"><vh>#374: Leo can confuse directives with decorators</vh></v>
<v t="ekr.20170316113823.22"><vh>#375: improve jedit.setTag</vh></v>
<v t="ekr.20170316113823.23"><vh>#380: New colorizer doesn't update properly...</vh></v>
<v t="ekr.20170316113823.24"><vh>#381: (default importer encoding problems)</vh></v>
<v t="ekr.20170316113823.25"><vh>#387: New file is marked as changed</vh></v>
<v t="ekr.20170316113823.26"><vh>#388: wikiview plugin</vh></v>
<v t="ekr.20170316113823.27"><vh>#389: syntax coloring changes</vh></v>
<v t="ekr.20170316113823.28"><vh>#391: Read File Into Node" with empty file</vh></v>
<v t="ekr.20170316113823.29"><vh>#392: @auto-rst file.txt: -rst ignored on read</vh></v>
<v t="ekr.20170316113823.30"><vh>#395: beautify-node can hang</vh></v>
<v t="ekr.20170316113823.31"><vh>#396: Show images in Leo's body pane </vh></v>
<v t="ekr.20170316113823.32"><vh>#402: python's input statement hangs Leo</vh></v>
<v t="ekr.20170316113823.33"><vh>#403: goto-global-line error</vh></v>
<v t="ekr.20170316113823.34"><vh>#408: c.recursiveImport uncaught exception...</vh></v>
<v t="ekr.20170316113823.35"><vh>#409: urls no longer colored</vh></v>
<v t="ekr.20170316113823.36"><vh>#416: PageUp binding problem</vh></v>
<v t="ekr.20170316113823.37"><vh>#426: console registerCommand - Chapter_hoist plugin</vh></v>
<v t="ekr.20170316113823.38"><vh>#427: multiple vnodes...</vh></v>
<v t="ekr.20170316113823.39"><vh>#429: goto line number...</vh></v>
<v t="ekr.20170316113823.40"><vh>#430: rst import...</vh></v>
<v t="ekr.20170316113823.41"><vh>#431: Simplify importer tables</vh></v>
<v t="ekr.20170316113823.42"><vh>#434: Potential bug in settings</vh></v>
<v t="ekr.20170316113823.43"><vh>Disabled compare_ast</vh></v>
<v t="ekr.20170316113823.44"><vh>Fixed attribute error in To_Python.go</vh></v>
<v t="ekr.20170316113823.45"><vh>Fixed bug in bracket matching</vh></v>
<v t="ekr.20170316113823.46"><vh>Fixed bug in rst3 command</vh></v>
<v t="ekr.20170316113823.47"><vh>Fixed crash after ! in tab completion</vh></v>
<v t="ekr.20170316113823.48"><vh>Fixed crash in autocomplete (with backspace key?)</vh></v>
<v t="ekr.20170316113823.49"><vh>Fixed crash in elisp importer</vh></v>
<v t="ekr.20170316113823.50"><vh>Fixed date in About Leo dialog</vh></v>
<v t="ekr.20170316113823.51"><vh>Fixed problem when ~/.leo/workbook.leo does not exist</vh></v>
<v t="ekr.20170316113823.52"><vh>Fixed recursive import problems</vh></v>
<v t="ekr.20170316113823.53"><vh>Fixed several importer bugs</vh></v>
<v t="ekr.20170316113823.54"><vh>g.findRootWithPredicate preserves node order</vh></v>
<v t="ekr.20170316113823.55"><vh>g.openUrlOnClick now catches all exceptions</vh></v>
<v t="ekr.20170316113823.56"><vh>The pylint command now runs files in the expected order</vh></v>
</v>
<v t="ekr.20170316113823.57"><vh>Code</vh>
<v t="ekr.20170316113823.58"><vh>Added BackgroundProcessManager class</vh></v>
<v t="ekr.20170316113823.59"><vh>Added four new generators</vh></v>
<v t="ekr.20170316113823.60"><vh>Added g.findRootWithPredicate</vh></v>
<v t="ekr.20170316113823.61"><vh>Added IdleTimeManager</vh></v>
<v t="ekr.20170316113823.62"><vh>All generators yield copies of positions</vh></v>
<v t="ekr.20170316113823.63"><vh>Created g.handleUnl</vh></v>
<v t="ekr.20170316113823.64"><vh>Replaced c.nullPosition() by None</vh></v>
<v t="ekr.20170316113823.65"><vh>Rewrote FreeMindImporter class</vh></v>
<v t="ekr.20170316113823.66"><vh>Simplified Leo's read/write helpers</vh></v>
</v>
<v t="ekr.20170316113823.67"><vh>Documentation</vh>
<v t="ekr.20170316113823.68"><vh>Added new entries to the plugins documentation</vh></v>
</v>
<v t="ekr.20170316113823.69"><vh>Features</vh>
<v t="ekr.20170316113823.70"><vh>#257: chapter-select-forward/back</vh></v>
<v t="ekr.20170316113823.71"><vh>#349: Added --load-type=LOAD_TYPE command-line option</vh></v>
<v t="ekr.20170316113823.72"><vh>#356: Scripting docs for hew users</vh></v>
<v t="ekr.20170316113823.73"><vh>#379: Removed many never-used commands</vh></v>
<v t="ekr.20170316113823.74"><vh>#438: Allow script abbreviations in headlines</vh></v>
<v t="ekr.20170316113823.75"><vh>&lt;Alt-X&gt;99 is the same as &lt;Alt-G&gt;99</vh></v>
<v t="ekr.20170316113823.76"><vh>Added decluttering of headlines</vh></v>
<v t="ekr.20170316113823.77"><vh>Added justify-toggle-auto and autojustify-on-at-start</vh></v>
<v t="ekr.20170316113823.78"><vh>Added leo/Icons/transparent folders and icons</vh></v>
<v t="ekr.20170316113823.79"><vh>Added open-themes-leo command and corresponding menu item</vh></v>
<v t="ekr.20170316113823.80"><vh>Added several new scripts and @button nodes to scripts.leo</vh></v>
<v t="ekr.20170316113823.81"><vh>leoDist.leo appears in the File menu</vh></v>
<v t="ekr.20170316113823.82"><vh>New unl:// links replace file:// syntax</vh></v>
<v t="ekr.20170316113823.83"><vh>re: Make UNL links active</vh></v>
<v t="ekr.20170316113823.84"><vh>Added reload-settings and reload-all-settings commands</vh></v>
<v t="ekr.20170316113823.85"><vh>Rewrote leomail plugin</vh></v>
<v t="ekr.20170316113823.86"><vh>The markdown importer now regularizes sections</vh></v>
<v t="ekr.20170316113823.87"><vh>VR supports @jupyter</vh></v>
</v>
<v t="ekr.20170316113823.88"><vh>Settings and command-line options</vh></v>
</v>
<v t="ekr.20170911085243.1"><vh>Leo 5.6</vh></v>
<v t="maphew.20171107045903.1"><vh>Leo 5.6.1</vh></v>
</v>
<v t="ekr.20180212094405.1"><vh>Leo 5.7 final release notes</vh></v>
<v t="EKR.20040519091259.2"><vh>Quotes of the month</vh>
<v t="ekr.20080901114425.2"><vh>Sept 2008</vh></v>
<v t="ekr.20070425092712"><vh>April 2007</vh></v>
<v t="ekr.20070101093904"><vh>January 2007</vh></v>
<v t="ekr.20060823090437"><vh>August 2006</vh></v>
<v t="ekr.20060213160806"><vh>February 2005</vh></v>
<v t="ekr.20040828084148"><vh>August 2004</vh></v>
<v t="ekr.20040630210818"><vh>July 2004</vh></v>
<v t="EKR.20040519091259.3"><vh>November 2003</vh></v>
<v t="EKR.20040519091259.4"><vh>October 2003</vh></v>
</v>
</v>
<v t="ekr.20150326055410.1"><vh>Update versions</vh></v>
<v t="ekr.20150416081546.1"><vh>Distribution check scripts</vh>
<v t="ekr.20150416081546.2"><vh>Catch mixed newlines in distribution files</vh>
<v t="ekr.20150416081546.3"><vh>check</vh></v>
</v>
<v t="ekr.20150416081546.4"><vh>Catch mixed tab &amp; space in derived files</vh>
<v t="ekr.20150416081546.5"><vh>check</vh></v>
</v>
<v t="ekr.20150416081546.6"><vh>Check all colorizer files for problem regex's</vh></v>
<v t="ekr.20150416081546.7"><vh>Clean ekr-spellpyx.txt</vh></v>
<v t="ekr.20150416081546.8"><vh>Linux install script</vh></v>
<v t="ekr.20150416081546.9"><vh>Warn if leoProjects.txt or leoToDo.txt contain clones</vh></v>
</v>
<v t="EKR.20040519090846"><vh>Distribution files</vh>
<v t="ekr.20141016105045.2119"><vh>@asis ../../.gitattributes</vh></v>
<v t="ekr.20130809141000.1990"><vh>@asis ../../INSTALL.TXT</vh>
<v t="ekr.20130809141000.1991"><vh>System requirements</vh></v>
<v t="ekr.20130809141000.1992"><vh>Leo's HOME directory</vh></v>
<v t="ekr.20130809141000.1993"><vh>Linux installation</vh></v>
<v t="ekr.20130809141000.1994"><vh>Windows installation</vh></v>
<v t="ekr.20130809141000.1995"><vh>Running Leo</vh></v>
<v t="ekr.20130809141000.1996"><vh>Creating file associations</vh></v>
<v t="ekr.20130809141000.1997"><vh>Adding Leo to your path</vh></v>
<v t="ekr.20130809141000.1998"><vh>Running Leo for the first time</vh></v>
</v>
<v t="EKR.20040519090846.1"><vh>@asis ../../LICENSE</vh></v>
<v t="EKR.20040519090846.8"><vh>@asis ../../PKG-INFO.TXT</vh></v>
<v t="EKR.20040519090846.9"><vh>@asis ../../README.md</vh></v>
<v t="ekr.20151227063335.1"><vh>@asis ../../About leo.exe.TXT</vh></v>
<v t="ekr.20150425135153.1"><vh>homebrew istall script</vh>
<v t="ekr.20150425135153.2"><vh>brew install formula</vh></v>
</v>
</v>
<v t="ekr.20141118074110.4"><vh>How to...</vh>
<v t="ekr.20141118074110.3"><vh>How to Install Leo on Linux</vh></v>
<v t="maphew.20180128212042.1"><vh>How to build Leo's PyPi Package</vh>
<v t="maphew.20180128212042.3"><vh>Create an PyPi.org account</vh></v>
<v t="maphew.20180128212042.2"><vh>Build requirements</vh></v>
<v t="maphew.20180128212042.4"><vh>Build &amp; publish a release</vh></v>
<v t="maphew.20180128213245.1"><vh>Not recommended: Test with TestPyPI</vh></v>
<v t="maphew.20180128212042.5"><vh>Caveats</vh></v>
</v>
<v t="ekr.20180124100848.1"><vh>Failures in unified version</vh></v>
</v>
<v t="ekr.20100202061222.1494"><vh>Distribution checklist</vh>
<v t="ekr.20161015091353.2"><vh>Files</vh></v>
<v t="ekr.20161015091353.1"><vh>Web docs</vh></v>
<v t="ekr.20161015091350.1"><vh>Pre-testing</vh></v>
<v t="ekr.20161015092224.1"><vh>Create distribution</vh></v>
<v t="ekr.20161020040946.1"><vh>Test</vh></v>
<v t="ekr.20161020041000.1"><vh>Create git tag</vh></v>
<v t="ekr.20170316104916.1"><vh>Publish release</vh></v>
<v t="ekr.20161015091353.3"><vh>Announcements</vh></v>
</v>
<v t="ekr.20101027131034.1490"><vh>NSIS source files</vh>
<v t="ekr.20101027160251.1500"><vh>Notes</vh>
<v t="ekr.20101027135430.1492"><vh>@url nsi new ui readme</vh></v>
<v t="ekr.20101027135430.1493"><vh>@url about pages</vh></v>
<v t="ekr.20101027160251.1497"><vh>@url nsDialogs</vh></v>
</v>
<v t="ekr.20160510090441.1"><vh>@file ../../leo_assoc.nsi</vh></v>
<v t="ekr.20101027054254.1590"><vh>@file ../../leo.nsi</vh></v>
</v>
<v t="ekr.20101027070126.1639"><vh>@button make leo</vh>
<v t="ekr.20090905082405.1487"><vh>&lt;&lt; includes &gt;&gt;</vh></v>
<v t="ekr.20110614062644.1379"><vh>&lt;&lt; define global paths and file names &gt;&gt;</vh></v>
<v t="ekr.20101027070126.1643"><vh>class LeoMaker</vh>
<v t="ekr.20101027070126.1662"><vh>run &amp; helpers</vh>
<v t="ekr.20101105103524.1494"><vh>clean_manifest</vh></v>
<v t="ekr.20110603171959.1506"><vh>clean_spellpyx</vh></v>
<v t="ekr.20141016123713.2120"><vh>copy_nsi_files (Not used)</vh></v>
<v t="ekr.20110614062644.1378"><vh>copy_ref_files (Not used)</vh></v>
<v t="ekr.20101027070126.1675"><vh>create_install_files</vh></v>
<v t="ekr.20101027070126.1676"><vh>create_uninstall_files</vh></v>
<v t="ekr.20101027070126.1663"><vh>directoryList</vh></v>
<v t="ekr.20101027070126.1664"><vh>filterLines &amp; helpers</vh>
<v t="ekr.20101027070126.1665"><vh>delete...</vh></v>
</v>
<v t="ekr.20101105103524.1491"><vh>make_manifest</vh></v>
<v t="ekr.20101105103524.1493"><vh>make_zip</vh></v>
<v t="ekr.20101027070126.1666"><vh>makeDicts</vh></v>
<v t="ekr.20101027070126.1667"><vh>printMissing</vh></v>
<v t="ekr.20161017070909.1"><vh>remove_commit_timestamp_json (Not used)</vh></v>
</v>
<v t="ekr.20101027070126.1680"><vh>utils...</vh>
<v t="ekr.20101027070126.1679"><vh>openFile</vh></v>
<v t="ekr.20101027070126.1678"><vh>put</vh></v>
<v t="ekr.20090905082405.1490"><vh>unlink</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040519090846">@language rest
@wrap
</t>
<t tx="EKR.20040519090846.1">MIT License

Copyright (c) 1997-2018 by Edward K. Ream.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</t>
<t tx="EKR.20040519090846.8">Metadata-Version: 1.0
Name: leo
Version: 5.7
Summary: An IDE, PIM and Outliner. See leoeditor.com/preface.html.
Description: See users own descriptions of Leo at leoeditor.com/testimonials.html.
Home-page: http://leoeditor.com/
Author: Edward K. Ream
Author-email: edreamleo@gmail.com
License: MIT
Keywords: Outliner, IDE, PIM, DAG, Scripting
Platform: Windows, Linux, MaxOS
Classifier: Development Status :: 6 - Mature
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: MacOS
Classifier: Operating System :: Microsoft :: Windows
Classifier: Operating System :: POSIX :: Linux
Classifier: Programming Language :: Python
Classifier: Topic :: Software Development
Classifier: Topic :: Text Processing
Download-URL: http://sourceforge.net/projects/leo/files/

</t>
<t tx="EKR.20040519090846.9">Leo 5.7 final February 27, 2018

Leo 5.7 final, http://leoeditor.com, is now available on [SourceForge](http://sourceforge.net/projects/leo/files/Leo/) and on [GitHub](https://github.com/leo-editor/leo-editor).

Leo is an IDE, outliner and PIM, as described [here](http://leoeditor.com/preface.html).

Simulating Leo's features in Vim, Emacs or Eclipse is possible, just as it is possible to simulate Python in C or assembly language...

**The highlights of Leo 5.7**

- pip install leo.
- A debian package for Leo.
- A web-based Leo Viewer, written by Joe Orr.
- Added diff-leo-files and diff-and-open-leo-files commands.
  These create outline-oriented diffs for .leo files.
- New reload-settings command.
- Leo optionally shows user tips on startup.
- Added a new Tips page to Leo's documentation.
- A visual widget for editing cvs tables.
- Spell checking works without pyenchant
- Improved the console_gui plugin.
- Added live links from urls in the log pane.
- Unit tests use a string gui, making them faster and more robust.
- The line_numbering plugin shows line numbers in external files.
- Improved the javascript importer.
- Added a TreePad importer.
- Added 6 new commands.
- Dozens of bug fixes.

**Links**

- Leo's home page: http://leoeditor.com
- [Documentation](http://leoeditor.com/leo_toc.html)
- [Tutorials](http://leoeditor.com/tutorial.html)
- [Video tutorials](http://leoeditor.com/screencasts.html)
- [Forum](http://groups.google.com/group/leo-editor)
- [Download](http://sourceforge.net/projects/leo/files/)
- [Leo on GitHub](https://github.com/leo-editor/leo-editor)
- [LeoVue](https://github.com/kaleguy/leovue#leo-vue)
- [What people are saying about Leo](http://leoeditor.com/testimonials.html)
- [A web page that displays .leo files](http://leoeditor.com/load-leo.html)
- [More links](http://leoeditor.com/leoLinks.html)
</t>
<t tx="EKR.20040519091259">@pagewidth 70
@language rest
@wrap

Markdown is all that is needed:

1. SourceForge (and github) accepts markdown and generates html.
2. Create leo-editor &amp; google groups announcements by
   copy/paste from resulting SourceForge announcement.
3. Get actual html using the HTML tab in my blog.
</t>
<t tx="EKR.20040519091259.1">5.1:        setup: 1,114    zip: 2,912
5.0:        setup: 552      zip: 1,617
4.4.5       setup: 547   zip: 379  2007-12-11
4.4.4       setup: 856  zip: 539  2007-11-02
4.4.3.1     setup: 1092 zip: 743  2007-7-03
4.4.3       setup: 363  zip: 282  2007-6-26
4.4.2.1     setup: 2847 zip: 2044 2006-10-19
4.4.1.1     setup: 1041 zip: 813  2006-9-3
4.4         setup: 1318 zip: 1075 2006-5-11
3.3.3       setup: 1503 zip: 1145 2005-9-19
4.3.2 final setup: 409  zip: 222
4.3.1 final setup: 2168 zip: 1781
4.3 final   setup: 942  zip: 686
4.2.1 final setup: 413  zip: 490
4.2-final   setup: 1828 zip: 1508
4.2b3       setup: 563, zip: 338
4.1rc3      setup: 870  zip: 630
4.1 b5      setup: 195, zip: 128
4.0.4       setup: 340, zip: 385
4.0                     zip: 382
3.12        setup: 953  zip: 592
3.11                    zip: 102
3.10                    zip: 1193</t>
<t tx="EKR.20040519091259.2"></t>
<t tx="EKR.20040519091259.3">I like Leo more the more I use it...It's an unexpected pleasure to
see my (linearly written) code outlined in Leo. I can't wait to use
Leo to start a new project, going from outline to code...Thanks again
for providing the computing community with such a fine piece of
software. -- Jim Shapiro, Ph.D.

If you think you have used all possible programmer's editors, but
have not yet tried Leo, you are wrong...I rate Leo as a "must have"
for Python programmers. The code makes for a good read.
-- John Tobler  http://weblogs.asp.net/Jtobler/
</t>
<t tx="EKR.20040519091259.4">I've written documentation in WordPerfert, Ventura, Word, PageMaker, and
FrameMaker and even though they create wonderfully looking and useful
documents, they've never been able to do what I've been looking for. HTML,
compiled help files, and later PDF came closer, but still not there. I think
I've found it in LEO, a way to make a "living" document. A document built out
of discrete parts that can be re-organized on the fly to meet the needs of a
varying audience...Being a convert for less than a day I've still got a lot to
learn, but just the possibility of keeping system maintenance scripts in the IT
manual is mind boggling.  -- David Nichols dnichols@amci.com</t>
<t tx="ekr.20040630210818">HTML Editing in Leo is soooo much easier then with NoNodeEditors. Ive
had a blast working on a web page. Usually I had to look at a bunch of
gunk all at once. Now I can look at little pieces of gunk! :) 

-Anon (for now)

Before leo, I try to avoid or refactor long functions. With leo, I am
very tempted not to. Being able to view and slice my code at a higher
level in pretty much anyway I want, I feel like a commanding master in
my own mess...Leo lets me be lazy and get away with it. ;)

Mark Ng

[Quote] I have just finished a little embedded system for someone, written in
C using leo as the editor. I told the customer he _had_ to use leo for
ongoing maintenance, after I looked at one of the main state machines:
600 lines in the derived file, but trivially easy to get your head
around in Leo...

The good news is that having been forced to meet leo he thinks it'll
solve many other problems that his company has with code maintenance.
Another step to world domination!

Leo allows you to do things that you'd never consider with another editor. 

BTW: in a real-time embedded system like I was working on, not having
the overhead of a function call (which you'd have had if you'd split
the case statement as you would with a normal editor) saves time, and
makes the system more flexible...
[End Quote]</t>
<t tx="ekr.20040828084148">Leo is the best IDE that I have had the pleasure to use. I have been using it
now for about 2 -- 3 months. It has totally changed not only the way that I
program, but also the way that I store and organize all of the information that
I need for the job that I do. -- Ian Mulvany</t>
<t tx="ekr.20050315084904"></t>
<t tx="ekr.20060213160806">"Thanks for a wonderful program – everybody should be using it! It blows the
socks off that Java Mind mapping software that won project of the month a while
back on sourceforge!" -- Derick van Niekerk.
</t>
<t tx="ekr.20060823090437">Thanks for creating the most useful and amazing application that
I've come across in years. I use Leo every day.</t>
<t tx="ekr.20070101093904">Leo is THE BEST THING to ever had happened to me. I've done in two
weeks what would have taken me years (not exaggerating!). Thanks Ed
for a terrific tool!!!!
 
Julian S. Fecteau 
</t>
<t tx="ekr.20070325123540"></t>
<t tx="ekr.20070425092712">Leo--especially with its feature of user-controllable outlining and
overview __has for the last 4-5 years had the greatest positive effect
on my overall programming quality of life than anything else out there
in the software world (apart maybe from the Python language itself,
and those who contribute Python modules to the world). -- David McNab
</t>
<t tx="ekr.20080901114425.2">For me Squeak and Leo have been two of the most significant technologies to
redefine my personal computer experience and the ideas behind computing.</t>
<t tx="ekr.20090901092556.1576">def genUninstallData(self,dirs,dirDict,filesDict):

    '''Generate the manifest-specific uninstall data.'''

    trace = True

    s = r'''
Section Uninstall

    DeleteRegKey HKEY_LOCAL_MACHINE "${hkey_local_machine}"

    ; Delete files &amp; directories only if we own them!
    ReadRegStr $$1 HKCR "${ext}" ""
    StrCmp $$1 "${name}File" 0 FinishUninstall

    ; Delete files &amp; directories only if there is no backup_val key.
    ReadRegStr $$1 HKCR "${ext}" "backup_val"
    StrCmp $$1 "" 0 DeleteLeoKeysAndFiles
      DeleteRegKey HKCR "${ext}"
    Goto FinishUninstall

DeleteLeoKeysAndFiles:
    WriteRegStr HKCR "${ext}" "" $$1
    DeleteRegValue HKCR "${ext}" "backup_val"

    ; ---- Start of manifest-related data...
'''

    self.put(s,substitute=True)

    # Does all the hard work.
    s = self.getUninstallVariableData(dirs,dirDict,filesDict)
    if trace: g.trace('\n',s)
    self.put(s,adjust = False)

    s = r'''
    ; ---- End of manifest related data.

FinishUninstall:
    ; MessageBox MB_YESNO|MB_ICONQUESTION \
    ;    "Delete all files in ${INSTDIR}?" IDNO NoDelete
; NoDelete:

  Delete "${SMPROGRAMS}\${name}\Uninstall.lnk"
  RMDir "${SMPROGRAMS}\${name}-${version}"
  Delete "${DESKTOP}\${name}.lnk"

  DeleteRegKey ${uninst_root_key} "${uninst_key}"
  SetAutoClose false

; end Uninstall section
SectionEnd
'''

    self.put(s,substitute=True)
</t>
<t tx="ekr.20090901121423.1567">def getUninstallVariableData(self,dirs,dirDict,filesDict):

    s1 = self.getDeleteFiles(dirs,dirDict,filesDict)
    s2 = self.getDeleteDirectories(dirs,dirDict)
    return '%s\n%s' % (s1,s2)
</t>
<t tx="ekr.20090901121423.1568">def getDeleteDirectories (self,dirs,dirDict):

    reverseDirs = dirs[:]
    reverseDirs.reverse()

    result = []

    if 1:
        result.append('; Recursively delete the leo directory and everything in it.\n')
        result.append('RMDir /r "$INSTDIR\\leo"\n\n')
    else:
        result.append('; Uninstall directories in reverse order\n')
        for theDir in reverseDirs:
            # Delete the directory even if it has files.
            if theDir and theDir != '**top':
                if not theDir.startswith('.bzr'):
                    result.append('RMDir "$INSTDIR\\%s"\n' % (
                        theDir.replace('/','\\')))

    # top-level folder.
    result.append('; Delete the top-level directory.\n')
    result.append('RMDir "$INSTDIR"\n')

    result = [self.indent(z) for z in result]
    return ''.join(result)
</t>
<t tx="ekr.20090901121423.1569">def getDeleteFiles (self,dirs,dirDict,filesDict):

    result = []
    result.append('\n')
    result.append('; Uninstall files...\n\n')

    # top-level files.
    result.append('; Delete top-level files...\n')
    aList = dirDict.get('**top',[])
    # Add *.py, *.pyo, *.pyc and *.leo, the most common added files.
    if 0: # This seems way too drastic, and not needed.
        for fn in ('*.py','*.pyo','*.pyc','*.leo',):
            aList.append(fn)
    # special case.
    aList.append('uninst.exe')
    # Warning: **never** delete all files in the top-level directory.
    for fn in aList:
        result.append('Delete "$INSTDIR\\%s"\n' % fn)

    if 0:
        wildcard_delete = True
        if wildcard_delete:
            result.append('\n')
        # Use the \r option to recursively delete everything in the leo directory.

        for theDir in dirs:
            if theDir:
                dir2 = theDir.replace('/','\\')
                if wildcard_delete:
                    result.append('Delete "$INSTDIR\\%s\\*.*"\n' % (dir2))
                else:
                    aList = dirDict.get(theDir,[])
                    if aList:
                        result.append('\n')
                        result.append('Delete "$INSTDIR\\%s\\*.pyc"\n' % (dir2))
                        result.append('Delete "$INSTDIR\\%s\\*.pyo"\n' % (dir2))
                    for fn in aList:
                        result.append('Delete "$INSTDIR\\%s\\%s"\n' % (
                            dir2,fn))

    result = [self.indent(z) for z in result]
    return ''.join(result)
</t>
<t tx="ekr.20090905082405.1487">import os
import shutil
# import string
# import struct
# import subprocess
# import sys
# import time
# import leo.core.leoVersion as leoVersion
</t>
<t tx="ekr.20090905082405.1490">def unlink (self,fn):

    # print('command: unlink: %s' % fn)
    os.remove(fn)
</t>
<t tx="ekr.20100202061222.1494">@language rest
</t>
<t tx="ekr.20101025095431.1517">@language rest</t>
<t tx="ekr.20101025095431.1518">https://bugs.launchpad.net/leo-editor/+bug/514656
</t>
<t tx="ekr.20101026142031.1516">@nocolor-node

HKEY_CURRENT_USER\Software\Classes\Applications\python.exe
HKEY_CURRENT_USER\Software\Classes\Applications\python.exe\shell\open\command
    val = c:\Python26\python.exe %1
HKCU
HKEY_CURRENT_USER\Software\Classes\Applications\pythonw.exe
HKEY_CURRENT_USER\Software\Classes\Applications\pythonw.exe\shell\open\command
    val = c:\Python26\pythonw.exe %1

HKEY_CURRENT_USER\Software\Classes\Applications\py_auto_file\shell\open\command
    val = c:\Python26\python.exe %1
    
HKEY_CURRENT_USER\Software\Classes\Installer\Products\nnnnnn

HKLM
HKEY_LOCAL_MACHINE\SOFTWARE\Python
HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonCore
HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonCore\2.7\InstallPath
    val = c:\python27\
HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonPath
    val = c:\Python27\Lib;\Python27\DLLs;C:\Python27\Lib\lib-tk
</t>
<t tx="ekr.20101027070126.1639"># Commit all files before running this script.

'''
Make these files in the top-level folder::

    git-manifest.txt
    nsi-install-files.txt
    nsi-uninstall-files.txt
    leo.zip.
'''

version = '5.7 final' ##version
&lt;&lt; includes &gt;&gt;
&lt;&lt; define global paths and file names &gt;&gt;

@others

LeoMaker().run()
g.es_print('done') # '@button make-leo done')
</t>
<t tx="ekr.20101027070126.1643">class LeoMaker:
    '''
    A class to make these files in the leo-editor folder:

    - git-manifest.txt.
    - nsi-install-files.txt
    - nsi-uninstall-files.txt
    - leo.zip
    '''

    @others
</t>
<t tx="ekr.20101027070126.1662">def run (self):
    '''The top-level logic.'''
    g.cls()
    # No longer exists. Done by git hooks.
        # leoVersion.create_commit_timestamp_json()
            # Create leo/core/commit_timestamp.json.
    self.clean_spellpyx()
    self.make_manifest()
    files = self.clean_manifest()
    dirs = self.directoryList(rootDir)
        # Compute the list of all the directories.
    dirDict,filesDict = self.makeDicts(dirs,files)
        # Compute dictionaries of directories and files.
    errors = self.printMissing(files,dirDict,filesDict)
        # Print manifest lines not in either dict.
        # This is a crucial check.
    if not errors:
        self.create_install_files(dirs,dirDict,filesDict)
        self.create_uninstall_files(dirs,dirDict,filesDict)
        self.make_zip()
        # self.copy_nsi_files()
        # self.remove_commit_timestamp_json()
</t>
<t tx="ekr.20101027070126.1663">def directoryList (self,rootDir):
    '''
    Compute a top-down list of all directories.
    These directories start at the top-level directory.
    '''
    trace = False
    ignoreDirs = ('.bzr','.git','docs')
    # Important: this adds all directories on EKR's machine,
    # regardless of whether they appear in the manifest!
    result = [] ; n = len(rootDir)
    for z in os.walk(rootDir): # top-down traversal.
        dirpath, dirnames, filenames = z
        assert dirpath.startswith(rootDir),z
        if len(dirpath) &gt; n:
            path = dirpath[n+1:].replace('\\','/')
            result.append(path)
    for z2 in ignoreDirs:
        result = [ z for z in result if not z.startswith(z2)]
    if trace:
        g.trace('-' * 40)
        g.trace(g.listToString(result))
    return result
</t>
<t tx="ekr.20101027070126.1664">def filterLines (self,lines):
    '''Filter lines from the input manifest file.'''
    trace = False
    # Remove blank lines, comments, and .pyc and .pyo files.
    lines = self.deleteBlankLines(lines)
    lines = self.deleteComments(lines)
    lines = self.deleteTempFiles(lines)
    lines = self.deleteExt(lines,'.pyc')
    lines = self.deleteExt(lines,'.pyo')
    lines = self.deleteExt(lines,'.zip') # Don't include the zip file.
    lines = self.deleteExt(lines,'.exe') # Don't include the installer.
    # Remove specific files.
    deleteList = (
        '.bzrignore',
        '.gitignore',
        # 'bzr-manifest.txt',
        'git-manifest.txt',
        # 'bzr-small-manifest.txt',
        # 'setup.py',
        'stand_alone_globals.leo',
        'leoStandAloneGlobals',
        'leo/test/unittest/.leo_shadow/',
        'nsi.log.txt', # Can't write log while we are creating it.
        'leo/core/leoPy.leo',
        'leo/core/ekrLeoPy.leo',
    )
    lines = self.deleteFiles(lines,deleteList)
    # Delete all files in the top-level docs/ directory
    lines = [z for z in lines if not z.startswith('docs/')]
    if trace:
        g.trace('=' * 40)
        g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20101027070126.1665">def deleteBlankLines (self,lines):

    return [z.strip() for z in lines if z.strip()]

def deleteComments (self,lines):

    return [z for z in lines if not z.startswith('#')]

def deleteExt (self,lines,ext):

    return [z for z in lines if not z.endswith(ext)]

def deleteFiles (self,lines,deleteList):

    return [z for z in lines if not z in deleteList]

def deleteTempFiles (self,lines):

    for i in range(1,10):
        lines = [z for z in lines if not z.endswith('~%s~' % i)]
    return lines
</t>
<t tx="ekr.20101027070126.1666">def makeDicts (self,dirs,lines):

    trace = False ; verbose = True
    # Create the dirDict.
    # Keys are directories.
    # Values are files contained in each directory.
    dirDict = {}
    dirDict['**top'] = [] # Create an entry for the root directory.
    for z in dirs:
        dirDict[z] = []
        # Leo 5.4: Add leo/core/commit_timestamp.json
        # This file is in .gitignore, but we must write it here.
        if 0:
            if z == 'leo/core':
                # g.trace(z)
                # g.trace('Adding commit_timestamp.json')
                dirDict[z].append('commit_timestamp.json')
    # Assign files to dirDict.
    for line in lines:
        line = line.strip().replace('\\','/')
        if line in dirDict.keys():
            path,fn = None,None
        elif line.startswith('leo/'):
            path,fn = g.os_path_split(line)
        else:
            path,fn = '**top',line.strip()
        # Don't include top-level leo directory,
        # Do include leo/scripts/leo file.
        if fn and (path != '**top**' or fn != 'leo'):
            aList = dirDict.get(path,[])
            assert line not in aList,repr(line)
            aList.append(fn)
            dirDict[path]=aList
    # Trace the result.
    for theDir in sorted(dirDict):
        aList = dirDict.get(theDir)
        if aList and trace:
            if verbose:
                print() ; print(theDir)
                print(g.listToString(aList))
            else:
                print(theDir)
    # Create the inverse dict.
    filesDict = {}
    for theDir in sorted(dirDict):
        aList = dirDict.get(theDir)
        for fn in aList:
            path = g.choose(theDir=='**top',
                fn,'%s/%s' % (theDir,fn))
            filesDict[path] = theDir
            # if fn == 'wikiview.py': g.trace(fn,path)
    return dirDict,filesDict
</t>
<t tx="ekr.20101027070126.1667">def printMissing (self,files,dirDict,filesDict):
    '''A crucial check.'''
    errors = 0
    for fn in files:
        fn = fn.rstrip('/')
        if fn and fn not in dirDict and fn not in filesDict:
            g.es_print('missing',fn,color='red')
            errors += 1
    if errors:
        g.es_print('%s errors' % (errors),color='red')
    return errors
</t>
<t tx="ekr.20101027070126.1675">def create_install_files(self,dirs,dirDict,filesDict):
    '''Create leo/dist/nsi-install-files.txt'''
    global install_fn,rootDir
    put = self.put
    self.f = self.openFile(install_fn)
    if not self.f: return
    # Top level
    theDir = '**top'
    put('\n')
    put('; top-level\n')
    put('SetOutPath "$INSTDIR"\n')
    put('SetOverwrite ifnewer\n')
    aList = dirDict.get(theDir,[])
    for fn in aList:
        put('File "%s"\n' % fn)
    for theDir in dirs:
        if theDir != '**top':
            aList = dirDict.get(theDir,[])
            if aList:
                theDir2 = theDir.replace('/','\\').rstrip('\\')
                put('\n')
                put('SetOutPath $INSTDIR\\%s\n' % theDir2)
                for fn in aList:
                    # Fix bug 425369: quote file names.
                    put('File "%s\\%s\\%s"\n' % (
                        rootDir,theDir2,fn))
    self.f.close()
</t>
<t tx="ekr.20101027070126.1676">def create_uninstall_files(self,dirs,dirDict,filesDict):
    '''Create leo/dist/nsi-uninstall-files.txt'''
    def clean(s):
        return s.replace('/','\\')
    put = self.put
    self.f = self.openFile(uninstall_fn)
    if not self.f: return
    # Part 1: Delete top-level files.
    put('\n')
    put('; Uninstall files...\n\n')
    put('SetOutPath $Temp\n')
    # Get the list of top-level files.
    aList = dirDict.get('**top',[])
    # Add some special cases:
    for fn in ('*.pyo','*.pyc',
        'uninst.exe',
        # 'setup.py',
            # setup.py is now allowed at the top level.
        'git-manifest.txt'
    ):
        if fn not in aList:
            aList.append(fn)
    for fn in aList:
        # Always delete individual files.
        put('Delete "$INSTDIR\\%s"\n' % fn)
    if 1:
        # Just delete the leo folder with /r option.
        # This should be completely safe.
        put('RMDir /r "$INSTDIR\\leo"\n')
    else:
        # Part 2: Delete files in lower directories.
        for theDir in dirs:
            if theDir:
                dir2 = clean(theDir)
                aList = dirDict.get(theDir,[])
                if aList:
                    put('\n')
                    put('Delete "$INSTDIR\\%s\\*.pyc"\n' % (dir2))
                    put('Delete "$INSTDIR\\%s\\*.pyo"\n' % (dir2))
                    # Delete all files in any __pycache__ subdirectory.
                    put('Delete "$INSTDIR\\%s\\__pycache__\\*.pyc"\n' % (dir2))
                for fn in aList:
                    put('Delete "$INSTDIR\\%s\\%s"\n' % (dir2,fn))
        # Part 3: Delete directories.
        reverseDirs = dirs[:]
        reverseDirs.reverse()
        put('\n')
        put('; Uninstall directories in reverse order\n')
        for theDir in reverseDirs:
            # Delete the directory even if it has files.
            if theDir and theDir != '**top':
                if not theDir.startswith('.bzr'):
                    put('RMDir "$INSTDIR\\%s\\__pycache__"\n' % (clean(theDir)))
                    put('RMDir "$INSTDIR\\%s"\n' % (clean(theDir)))
    # Delete the op-level folder.
    put('\n')
    put('; Delete the top-level directory.\n')
    put('RMDir "$INSTDIR"\n')
        # Important: the /r option is not safe here!
    self.f.close()
</t>
<t tx="ekr.20101027070126.1678">def put (self,s):

    # g.trace(s.rstrip())
    self.f.write(s)
</t>
<t tx="ekr.20101027070126.1679">def openFile (self,fn,mode='w'):

    try:
        f = open(fn,mode)
        return f
    except IOError:
        g.error('can not open',fn)
        return None
</t>
<t tx="ekr.20101027070126.1680"></t>
<t tx="ekr.20101027131034.1490">@color</t>
<t tx="ekr.20101027135430.1492">http://nsis.sourceforge.net/Docs/Modern%20UI%202/Readme.html</t>
<t tx="ekr.20101027135430.1493">http://nsis.sourceforge.net/Docs/Chapter4.html#4.5</t>
<t tx="ekr.20101027160251.1497">http://nsis.sourceforge.net/Docs/nsDialogs/Readme.html</t>
<t tx="ekr.20101027160251.1500"></t>
<t tx="ekr.20101105103524.1491">def make_manifest(self):
    '''Create git-manifest.txt.'''
    os.chdir(rootDir) # Can't be done below.
    commands = (
        r'del git-manifest.txt',
        r'c:\apps\Git\bin\git.exe ls-files &gt; git-manifest.txt',
        # r'&amp;ed git-manifest.txt',
    )
    g.execute_shell_commands(commands,trace=True)
</t>
<t tx="ekr.20101105103524.1493">def make_zip(self):
    '''
    Create the zip file.
    
    The archive will not contain the .git directory, but will contain
    .gitignore, .gitattributes, etc. To suppress these files, use the
    export-ignore attribute in a .gitattributes file. Commit this before
    doing git archive.
    '''
    for z in (zipFile,zipFile2):
        if exists(z): self.unlink(z)
    os.chdir(rootDir) # Required.
    commands = (
        # This commit ensures the proper files are included in the distribution.
        # r'git commit -m "commit doc files during make"',
        ##version
        r'%s archive --format zip --output "%s" --prefix=Leo-5.7-final/ master' % (
            r'c:\apps\Git\bin\git.exe',zipFile),
    )
    g.execute_shell_commands(commands,trace=True)
    if not g.os_path_exists(zipFile):
        print('does not exist: %s' % zipFile)
    # Remove the temporary zip file.
    if exists(zipFile2):
        self.unlink(zipFile2)</t>
<t tx="ekr.20101105103524.1494">def clean_manifest(self):
    '''Create and filter the list of files from the manifest.'''
    f = open(manifest_fn)
    s = f.read()
    f.close()
    lines = g.splitLines(s)
    lines = self.filterLines(lines)
    # Write the file back.
    f = open(manifest_fn,'w')
    f.write('\n'.join(lines))
    f.close()
    return lines
</t>
<t tx="ekr.20101115090518.1494">Leo 4.8 final                               November 26, 2010

Leo 4.8 final is now available at:
http://sourceforge.net/projects/leo/files/

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/

The highlights of Leo 4.8:
--------------------------

- Leo now uses the simplest possible sentinel lines in external files.
  External files with sentinels now look like Emacs org-mode files.
- Leo Qt gui now supports Drag and Drop.
  This was one of the most frequently requested features.
- Improved abbreviation commands.
  You now define abbreviations in Leo settings nodes, not external files.
- @url nodes may contain url's in body text.
  This allows headlines to contain summaries: very useful.
- Leo now uses PyEnchant to check spelling.
- Leo can now open multiple files from the command line.
- Leo's ancient Tangle and Untangle commands are now deprecated.
  This will help newbies how to learn Leo.
- Leo now shows "Resurrected" and "Recovered" nodes.
  These protect data and show how data have changed.
  These fix several long-standing data-related problems.
- A new "screenshots" plugin for creating slide shows with Leo.
  I used this plugin to create Leo's introductory slide shows.
- Improved autocompletion: Ctrl-space starts a one-time completion.
- A better installer.
- Many bug fixes.

Links:
------
Leo:      http://leoeditor.com/
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20110603112852.1505">Leo 4.9 final              June 21, 2011

Leo 4.9 final is now available at:
http://sourceforge.net/projects/leo/files/

Leo is a text editor, data organizer, project manager and much more.
See: http://leoeditor.com/

The highlights of Leo 4.9:
--------------------------

- The Qt gui completely replaces the Tk gui--Qt gui now has all essential
  features of Tk, including plugins.

- Completed Leo's autocompleter.

- The rendering pane can now display movies, html, svg images, etc.

- The scrolledmessage plugin can now use the rendering pane.

- Nodes may contain multiple @language directives.

- Leo highlights URL's everywhere. Ctrl-click URL's opens them in your web
  browser. 

- Leo uses an @file node's extension by default if there is no @language
  directive in effect.
  
- Unified extract and import commands.

- Leo can now colorize multiple @language directives in a single node.

- Plain up/down arrow keys in headline-editing mode select a new node.

- New commands to insert, delete, change or print uA's.

- Added namespace directive to .leo files.

- Fixed many bugs, some important, most quite minor.

Links:
------
Leo:      http://leoeditor.com/
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/projects/leo/files/
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20110603171959.1506">def clean_spellpyx (self):
    '''Clean ekr-spellpyx.txt.'''
    fn = g.os_path_finalize_join(pluginsDir,'ekr-spellpyx.txt')
    if not g.os_path_exists(fn):
        return
    f = self.openFile(fn,mode='rb')
    s = f.read()
    f.close()
    s2 = s.replace(b'\r',b'')
    if s != s2:
        g.es_print('cleaning',fn)
        f = self.openFile(fn,mode='wb')
        f.write(s2)
        f.close()
</t>
<t tx="ekr.20110614062644.1378">def copy_ref_files (self):
    '''Copy reference copies of .leo files.'''
    if 0:
        # There seems to be no need for this.
        # Furthermore, this changes the ref files.
        table = (
            (pluginsDir,'leoGuiPlugins.leo','leoGuiPluginsRef.leo'),
            (pluginsDir,'leoPlugins.leo','leoPluginsRef.leo'),
            (coreDir,'leoPy.leo','leoPyRef.leo'),
        )
        for d,src,dst in table:
            src_path = join(d,src)
            dst_path = join(d,dst)
            if not exists(src_path):
                g.error('does not exist',src_path)
            if not exists(dst_path):
                g.error('does not exist',dst_path)
            if exists(src_path) and exists(dst_path):
                shutil.copyfile(src_path,dst_path)
</t>
<t tx="ekr.20110614062644.1379"># Globals...
abspath,exists,join = g.os_path_abspath,g.os_path_exists,g.os_path_join

# First.
# bzrRoot     = join('Lib','site-packages','Leo-%s' % (version))

    # Don't use abspath!
distDir     = abspath(join(g.app.loadDir,'..','dist'))
rootDir     = abspath(join(g.app.loadDir,'..','..')) # Same as top.
pluginsDir  = abspath(join(g.app.loadDir,'..','plugins'))

# Next.
coreDir =       abspath(join(g.app.loadDir,'..','core'))
docDir =        abspath(join(g.app.loadDir,'..','doc'))
docsDir =       abspath(join(g.app.loadDir,'..','..','docs'))
manifest_fn =   abspath(join(rootDir,'git-manifest.txt'))
# install_fn =    abspath(join(distDir,'nsi-install-files.txt'))
# uninstall_fn =  abspath(join(distDir,'nsi-uninstall-files.txt'))
install_fn =    abspath(join(rootDir,'nsi-install-files.txt'))
uninstall_fn =  abspath(join(rootDir,'nsi-uninstall-files.txt'))
zipFile =       abspath(join(rootDir,'Leo-%s.zip' % (version)))
zipFile2 =      abspath(join(rootDir,'Leo-%s-temp.zip' % (version)))

# assert g.os_path_exists(manifest)</t>
<t tx="ekr.20120328150744.1791">Leo 4.10 final                                         March 29, 2012

Leo 4.10 final is now available at: http://sourceforge.net/projects/leo/files/

Leo is a text editor, data organizer, project manager and much more.
http://leoeditor.com/

Leo 4.10 contains 9 months of intense work on Leo. Several very important
features are subtle; you could almost call them Easter Eggs, so please read
the following notes carefully.

The highlights of Leo 4.10:
--------------------------

* Dozens of new and improved features and commands, including...
  - Tab completion now shows all @command &amp; @button nodes.
  - Leo tabs may be detached from the main window.
  - The Open With menu now works.
  - The leoInspect module answers questions about Python code.
  - Leo can highlight the pane containing the focus.
  - The bigdash plugin searches across multiple files.
  - Improved abbreviation capabilities.
  - Improved handling of URL's.
  - Improved editing of non-Leo files.
  - Improvements create "weightless" unit testing.
  - Improved Leo's home page.
* Easier installation on MacOS.
* Fixed almost 70 bugs.

The Easter Eggs
---------------

1. Tab completion now shows all @command &amp; @button nodes.

Put all your common scripts in @command nodes in myLeoSettings.leo.
Typing &lt;Alt-X&gt;@c&lt;Tab&gt; will remind you of the names of these scripts.
You can execute the scripts by name without the "@command-" prefix.

2. Improved abbreviation capabilities.

Virtually any kind of abbreviation is possible. For example, ~a to ã.

3. Improved handling of URL's.

URL's can be used as links to other Leo outlines.

4 Weightless unit testing.

The mantra is edit, alt-4 (run-marked-unit-tests-externally), edit,
alt-4,... Several seemingly innocuous changes made this work without
"friction". The result is a remarkable increase in productivity.

Links:
------
Leo:      http://leoeditor.com/
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/projects/leo/files/
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20130809141000.1990">@language rest
</t>
<t tx="ekr.20130809141000.1991">System requirements
-------------------

Leo requires the `Python`_ and `PyQt_` package.
The `PyEnchant`_ package is optional. 

**Python**: Leo will work on any platform that supports Python 2.6 or
above, including Python 3.0 and above. To install Python, see
http://python.org.

**PyQt**: PyQt provides Leo's widgets. To install PyQt, get the binary
package from: http://www.riverbankcomputing.co.uk/software/pyqt/download
The PyQt version must match your installed Python version. Remember that
Leo requires Python 2.6 or later, or Python 3.0 or later. Now run the
binary PyQt installer.

**PyEnchant**: You must install the PyEnchant package if you want to use
Leo's Spell tab. Download and install the PyEnchant package from
http://pythonhosted.org/pyenchant/download.html There is an executable
installer for Windows users.

</t>
<t tx="ekr.20130809141000.1992">
Leo's HOME directory
--------------------

Python's HOME environment variable specifies Leo's HOME directory.
See http://docs.python.org/lib/os-procinfo.html for details.

Leo puts several files in your HOME/.leo directory:
.leoID.txt, .leoRecentFiles.txt, and myLeoSettings.leo.
There are various fallback directories if there is no home directory.
</t>
<t tx="ekr.20130809141000.1993">
Installing Leo on Linux
-----------------------

You may download Leo's sources in one of three ways, as described at:
http://leoeditor.com/download.html If the sources are zipped, unzip them
into a folder in your home directory, say ~/leo-5.2 (or /usr/bin, etc.)

To gain access to Leo, you have two choices:

A. Add  ~/leo-5.2 to your path.
B. Create alias for Leo.

I prefer using aliases because they allow me to start Leo using Python 2 or 3,
or other distributions, like Anaconda 2 or 3.

See `Running Leo`_ for how to run Leo after installing it.
</t>
<t tx="ekr.20130809141000.1994">
Installing Leo on Windows
--------------------------

Install Python and Qt, as described above.

Now you have a choice.  You can use Leo's binary (single-click) installer
or download Leo's sources directly.

1. Using the single-click installer

Leo has a binary installer for Windows, available at
http://sourceforge.net/projects/leo/files/Leo/ The binary installer
installs Leo and sets Windows file associations.

2. Installing from sources

You may download Leo's sources in one of three ways, as described at:
http://leoeditor.com/download.html If the sources are zipped, unpack them
into a temp folder. You may place the sources anywhere you like, including
Python's *site-packages* folder, for example,
C:\Python26\Lib\site-packages.

</t>
<t tx="ekr.20130809141000.1995">
Running Leo
-----------

You can run Leo from a Python interpreter as follows::

    import leo
    leo.run() # runs Leo, opening a new outline or,
    leo.run(fileName=aFileName) # runs Leo, opening the given file name.

Another way to run Leo is as follows::

    cd &lt;path-to-launchLeo.py&gt;
    python launchLeo.py
</t>
<t tx="ekr.20130809141000.1996">
Creating File Associations
--------------------------

**Linux**

The following shell script will allow you to open foo.leo files by typing leo foo::

    #!/bin/sh 
    python &lt;leopath&gt;launchLeo.py $1

where &lt;leopath&gt; is the path to the directory *containing* the leo directory. 

**Windows**

*Important*: Leo's binary Windows installer sets file associations
automatically, so this section is needed only if you are installing Leo
from a .zip file or other sources.

There are two ways of associating .leo files with Leo. The first uses the
Windows control panel, the second, the Windows console.

**Method 1: Using the Windows Control Panel**

The goal is that you want to associate .leo files with the following command::

    "&lt;path to python&gt;\python.exe" "&lt;path to launchLeo.py&gt;\launchLeo.py" "%1"
    
Before Windows 7, you do this with using the Folder Options control panel.
In Windows 7, you do this with the Default Programs control panel.

*Note*: "%1" passes just the file being clicked on, quoted for spaces etc.
The quotation marks are needed to handle file paths containing spaces.

*Warning:* In a batch file, %1 passes just the first command line parameter.
It is logical to expect %* to work for file associations just as in batch
files. Alas, it does not.

**Method 2: Using the Windows Console**

Open a Windows console with administrator privileges, then type::

    ftype LeoFile="&lt;path to python&gt;\pythonw.exe" "&lt;path to launchLeo.py&gt;\launchLeo.py" "%1" %*
    assoc .leo=LeoFile

And put this leo.bat in %PATH%::

    @start /b "Leo" "&lt;path to python&gt;\python.exe" "&lt;path to launchLeo.py&gt;\launchLeo.py" %*
    
You may omit the /b option if you want to create a separate console window for Leo.
</t>
<t tx="ekr.20130809141000.1997">
Adding Leo to Your Path
-----------------------

After you have installed Leo, you should add the location of your leo/core folder to your python path.
One way to do this is adding something like the following to python/Lib/sitecustomize.py:

    import sys
    sys.path.append(r'&lt;path-to-leo&gt;leo\core')

Another way is to append &lt;path-to-leo&gt; to the Windows PYTHONPATH environment variable.
</t>
<t tx="ekr.20130809141000.1998">
Running Leo for the first time
------------------------------

The first time you start Leo, a dialog will ask you for a unique identifier. If
you are using cvs, use your cvs login name. Otherwise your initials will do. Leo
stores this identifier in the file ``.leoID.txt``. Leo attempts to create
``leoID.txt`` in the .leo sub-directory of your home directory, then in Leo's config directory, and
finally in Leo's core directory. You can change this identifier at any time by
editing ``.leoID.txt``.
</t>
<t tx="ekr.20131105110107.16636">Leo 4.11 final released: Python scripting IDE

Leo 4.11 final is now available at: http://sourceforge.net/projects/leo/files/Leo/
Leo 4.11 contains over a year's work on Leo.

Leo is a PIM, an IDE and an outliner for programmers, authors and web
designers. Leo's unique features organize data in a revolutionary way.
Python scripts can easily access all parts of Leo outlines.
See http://leoeditor.com/tutorial.html

The highlights of Leo 4.11:
---------------------------

- Leo's tutorials have been rewritten and simplified.
- Greatly improved abbreviations, including templates.
- Clones are now valid anywhere in @file nodes.
- Leo now warns if a .leo file is open elsewhere.
- Leo's IPython bridge now works with IPython 1.x.
- Added support for @testsetup and @testclass.
- Added support for sessions.
- Added colorizing themes.
- A colored border highlights the pane with focus.
- Added support for the clojure, markdown and TypeScript languages.
- Added importers for .ipynb, .otl and vimoutliner files.
- Many new and improved commands, plugins and scripts.
- Dozens of bug fixes and code-level improvements.

Links:
------
Leo:       http://leoeditor.com
Docs:      http://leoeditor.com/leo_toc.html
Tutorials: http://leoeditor.com/tutorial.html
Forum:     http://groups.google.com/group/leo-editor
Download:  http://sourceforge.net/projects/leo/files/
Bzr:       http://code.launchpad.net/leo-editor/
Quotes:    http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20141016105045.2119"># .gitattributes file for Leo distribution

# Commit this file after changing it!

.gitattributes                  export-ignore
.gitignore                      export-ignore
nsi.log.txt                     export-ignore

git-manifest.txt                export-ignore
MakeFile                        export-ignore
MANIFEST.in                     export-ignore

leoStandAloneGlobals.py         export-ignore
stand_alone_globals.leo         export-ignore
# setup.cfg                     export-ignore
# setup.py                      export-ignore

# Do not include the top-level docs folder in distributions
docs/                           export-ignore
docs/*                          export-ignore

# Do not include various local files.
leo/core/leoPy.leo              export-ignore
leo/core/ekrLeoPy.leo           export-ignore
leo/test/unittest/.leo_shadow/  export-ignore

leo/core/commit_timestamp.json merge=ours
</t>
<t tx="ekr.20141016123713.2120">def copy_nsi_files(self):
    '''
    Copy these files from the leo\dist folder to the leo-editor folder::

        nsi-install-files.txt
        nsi-uninstall-files.txt
    '''
    assert False, g.callers()
    names = (
        'nsi-install-files.txt',
        'nsi-uninstall-files.txt',
        # 'nsi-boilerplate.txt',
    )
    for fn in names:
        src = g.os_path_join(distDir,fn)
        dst = g.os_path_join(rootDir,fn)
        assert g.os_path_exists(src),src
        shutil.copyfile(src,dst)
</t>
<t tx="ekr.20141105082156.2">Leo 5.0 final                       November 24, 2014

Leo 5.0-final is now available at:
http://sourceforge.net/projects/leo/files/Leo/

This release fixes several installation issues
and updates installation instructions for Linux/Ubuntu.

Leo is a PIM, an IDE and an outliner.
Video tutorials: http://leoeditor.com/screencasts.html
Text tutorials: http://leoeditor.com/tutorial.html

The highlights of Leo 5.0
--------------------------

* Better compatibility with vim, Emacs, pylint and PyQt:
    - Optional native emulation of vim commands.
    - Full support for Emacs org-mode outlines.
    - Full support for Vim .otl outlines.
    - Better support for pylint.
    - Support for both PyQt4 and PyQt5.
* Smoother installation:
    - Support for brew install leo on MacOS.
    - 'python setup.py install' now works.
    - pip install leo now works.
    - Leo is now a debian package.
* Better handling of nodes containing large text:
    - Idle time syntax coloring eliminates delay.
    - Optional delayed loading of large text.
* Power features:
    - Command history for minibuffer commands.
    - Leo available via github repository.
    - File name completion.
    - Cloned nodes expand and contract independently.
    - @data nodes can be composed from descendant nodes.
    - No need to change Leo's main style sheet:
      it can be customized with @color and @font settings.
    - @persistence nodes save data in @auto trees.
    - A pluggable architecture for @auto nodes.
    - The style-reload command changes Leo's appearance instantly.
* Important new plugins for tagging, display and node evaluation.
* For beginners:
    - Leo's default workbook files contains Leo's quickstart guide.
* Hundreds of new/improved features and bug fixes.

Links:
------
Leo:       http://leoeditor.com
Docs:      http://leoeditor.com/leo_toc.html
Tutorials: http://leoeditor.com/tutorial.html
Videos:    http://leoeditor.com/screencasts.html
Forum:     http://groups.google.com/group/leo-editor
Download:  http://sourceforge.net/projects/leo/files/
Github:    https://github.com/leo-editor/leo-editor
Quotes:    http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20141117135127.2"></t>
<t tx="ekr.20141117135127.3"></t>
<t tx="ekr.20141118074110.3">https://groups.google.com/forum/#!topic/leo-editor/VvnDYjV4aIk</t>
<t tx="ekr.20141118074110.4"></t>
<t tx="ekr.20150326055410.1">@language rest

1. Search for ##version

    **Note**: The final version in PKG-INFO.TXT must be called 5.x, not 5.x-final.
    See Pep 440: https://www.python.org/dev/peps/pep-0440/

2. Search for copyright

    Latest copyright date: 2018.

    Note: install.txt file embeds a copyright message in the nsi installer.</t>
<t tx="ekr.20150415145711.1">April 16, 2015

[Leo](http://leoeditor.com/) 5.1 final is now available [at SourceForge.](http://sourceforge.net/projects/leo/files/Leo/) Leo is a PIM, an IDE and an outliner.

Leo 5.1-final is recommended for anyone using Leo 5.1 b1 or Leo 5.0-final.

**The highlights of Leo 5.1**

This release features **@clean** trees, one of the most important developments in Leo's history.

@clean nodes create external files without sentinel comments, yet Leo can update @clean trees from changes made to the corresponding external files, something long thought impossible. @clean trees preserve clone links and user attributes (uA's). Reading @clean trees is faster than reading @auto or @shadow trees. Steve Zatz [explains why @clean changes everything.](http://leoeditor.com/testimonials.html#steve-zatz-explains-why-clean-changes-everything)

**More highlights**
 
* A new [web page](http://leoeditor.com/load-leo.html) displays .leo files in the browser.
  
* Added **command history** to Leo's minibuffer.

* A new IdleTime class greatly simplifies idle-time handling.

* Leo now honors @language inside @doc parts

* @data nodes can be composed of their descendant nodes.

* @shadow is now deprecated. @clean is superior to @shadow in all respects. 

**Links**

The [Mulder/Ream algorithm](http://leoeditor.com/appendices.html#the-mulder-ream-update-algorithm) updates @clean trees from changes made in the corresponding external files. 

[Leo's home page](http://leoeditor.com)
[Documentation](http://leoeditor.com/leo_toc.html)
[Tutorials](http://leoeditor.com/tutorial.html)
[Video tutorials](http://leoeditor.com/screencasts.html)
[Forum](http://groups.google.com/group/leo-editor)
[Download](http://sourceforge.net/projects/leo/files/)
[Leo on Github](https://github.com/leo-editor/leo-editor)
[What people are saying about Leo](http://leoeditor.com/testimonials.html)
[A web page that displays .leo files](http://leoeditor.com/load-leo.html)
[More links](http://leoeditor.com/leoLinks.html)
</t>
<t tx="ekr.20150416081546.1"></t>
<t tx="ekr.20150416081546.2">import glob

@others

verbose = False

# extraFiles = ('..\\install','..\\uninstall','test\\unittest\\perfectImport\\formatter.py',)
extraFiles = () # 'test\\test-line-ending.py',)

baseDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..'))
n = 0
dirs = ('','src','scripts','plugins',)
# dirs = ('src',)

if 1:
    for dir2 in dirs:
        theDir = g.os_path_abspath(g.os_path_join(baseDir,dir2))
        print theDir
        files1 = glob.glob('%s\*.py' % theDir)
        files2 = glob.glob('%s\*.leo' % theDir)
        files = files1
        files.extend(files2)
        for name in files:
            f = file(name)
            lines = f.readlines()
            # print '%5d %s' % (len(lines),name)
            f.close()
            check(name,lines)
            n += 1

for z in extraFiles:
    name = g.os_path_abspath(g.os_path_join(baseDir,z))
    f = file(name)
    lines = f.readlines()
    # print '%5d %s' % (len(lines),name)
    f.close()
    check(name,lines)
    n += 1

print 'done.  checked %d files' % (n)
</t>
<t tx="ekr.20150416081546.3">def check(name,lines):

    cr = 0 ; nl = 0

    for s in lines:
       for ch in s:
        if ch == '\r': cr += 1
        if ch == '\n': nl += 1

    if verbose or cr &gt; 0:
        print "%55s %s cr's %4s nl's" % (name,cr,nl)
</t>
<t tx="ekr.20150416081546.4">import glob

@others

baseDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..'))
n = 0
for dir2 in ('','src','scripts','plugins',):

    theDir = g.os_path_abspath(g.os_path_join(baseDir,dir2))
    print theDir
    files = glob.glob('%s\*.py' % theDir)
    for name in files:
        f = file(name)
        lines = f.readlines()
        # print '%5d %s' % (len(lines),name)
        f.close()
        check(name,lines)
        n += 1

print 'done.  checked %d files' % (n)
</t>
<t tx="ekr.20150416081546.5">def check(name,lines):

    n = 0
    for line in lines:
        n += 1
        i = g.skip_ws(line,0)
        lws = line[0:i]
        if lws:
            if lws.find(' ') &gt; -1 and lws.find('\t') &gt; -1:
                print '%20s %5d %s' % (name,n,repr(line))
</t>
<t tx="ekr.20150416081546.6">import glob
pattern = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
for fn in glob.glob(pattern):
    sfn = g.shortFileName(fn)
    f = open(fn)
    s = f.read()
    f.close()
    if s.find(r'regexp="\\') &gt; -1:
        g.es(sfn)

@ found: Rules indicated are dubious or broken

md.py:
    [ \t]   leadins: 8,20,24,25(?),50,51
    space   leadins: 23,46,49
    [=-]    leadins: 21,47
    [\\_]   leadins: 54,55
    #       leadins: 22
    other   leadins: 7,12,19,53

moin.py:
    [ \t]           rule 3.
    single-quote    rule 6.

erlang.py:  no obvious problem.
lilypond.py:no obvious problem.
perl.py:    no obvious problem.
pl1.py:     no obvious problem.
rest.py:    no obvious problem.
rtf.py:     no obvious problem.
scala.py:   no obvious problem.
yaml.py:    fixed</t>
<t tx="ekr.20150416081546.7">'''
Regularize newlines in ekr-spellpyx.txt.

Replaces sorts the file, removes duplicate lines and ensuring a trailing newline.
'''
fn = g.os_path_finalize_join(g.app.loadDir,'..','..','ekr-spellpyx.txt')
with open(fn) as f:
    s = ''.join(sorted(set(g.splitLines(f.read().strip()+'\n'))))
with open(fn,'w') as f:
    f.write(s)
</t>
<t tx="ekr.20150416081546.8">@first

"""
A simple script to install Leo on Linux.

Contributed by David McNab &lt;david@rebirthing.co.nz&gt;
"""

import commands,os,sys # commands module is for Unix only.

# We must be root to use this script.
if os.getuid() != 0:
    print "You need to run this install script as root"
    sys.exit(1)

# Create /usr/lib/leo and copy all files there.
print "***** Installing Leo to /usr/lib/leo..."
commands.getoutput("mkdir -p /usr/lib/leo")
commands.getoutput("cp -rp * /usr/lib/leo")

# Create user's 'leo' command script into /usr/bin/leo
print "***** Creating Leo startup script -&gt; /usr/bin/leo"
fd = open("/usr/bin/leo", "w")
fd.write("""#!/usr/bin/python
import commands,sys
files = " ".join(sys.argv[1:])
print commands.getoutput("python /usr/lib/leo/leo.py %s" % files)
""")
fd.close()
commands.getoutput("chmod 755 /usr/bin/leo")
print "***** Leo installed successfully - type 'leo filename.leo' to use it."
</t>
<t tx="ekr.20150416081546.9">@language python

# This script must be run from leoPy.leo.

'''Warn if leoProjects.txt or leoToDo.txt contain any clones.'''

clones,nodes,seen = 0,0,set()
table = (
  '@file ../doc/leoProjects.txt',
  '@file ../doc/leoToDo.txt',
)

def check_clone(c,p0,root):
    '''Warn if p appears in any @&lt;file&gt; node outside of root's tree.'''
    global nodes,seen
    v = p0.v
    for p in c.all_positions():
        nodes += 1
        if p.v == v:
            # Check *all* ancestors, not just the nearest one.
            for parent in p.self_and_parents():
                nodes += 1
                if parent.isAnyAtFileNode() and parent.v != root.v:
                    if parent.v not in seen:
                        seen.add(parent.v)
                        g.es_print('%s and %s contain clone: %s' % (
                            root.h,parent.h,p0.h))

for h in table:
    root = g.findNodeAnywhere(c,h)
    if root:
        for p in root.self_and_subtree():
            nodes += 1
            if p.isCloned():
                clones += 1
                check_clone(c,p,root)
    else:
        g.es_print('not found',h,color='red')
print('done: %s nodes, %s clones' % (nodes,clones))
</t>
<t tx="ekr.20150425135153.1">@language ruby
@tabwidth -2
</t>
<t tx="ekr.20150425135153.2">class Leo &lt; Formula

  homepage "http://leoeditor.com/"
  url "http://sourceforge.net/projects/leo/files/Leo/5.0-final/Leo-5.0-final.zip"
  sha256 "2d742f9825959ba5c7624d1179b9f3065e14e055c90272fbce199f91770de826"
  head "https://github.com/leo-editor/leo-editor", :using =&gt; :git

  depends_on "pyqt"
  depends_on "enchant" =&gt; :recommended
  depends_on :python if MacOS.version &lt;= :snow_leopard

  def install
    (lib+"python2.7/site-packages").install "leo"
    bin.install "launchLeo.py" =&gt; "leo" 
  end

  test do
    system bin/"python", "-c", "import leo"
  end
end
</t>
<t tx="ekr.20151227063335.1">leo.exe contains everything you need to run Leo on Windows without
installing *anything* else. It contains all needed libraries, including
Python itself, PyQt, pylint and other packages. It also contains many data
files, including Leo's source code and various .leo files.

Notes:

1. leo.exe was created by PyInstaller: http://pythonhosted.org/PyInstaller

2. Before Leo starts, PyInstaller unpacks all libraries and data files to a
   temp folder: ~\AppData\Local\Temp\_MEInnn. As a result, starting leo.exe
   is slower than usual.

3. *Warning*: You can open Leo files from the "Files:Open Leo File" menu,
   but these files will be in the temp folder. They will be *destroyed*
   when you exit leo.exe. If you want to do real work with Leo you must
   create .leo files in a permanent folder on your machine.
</t>
<t tx="ekr.20160314155002.1">Leo 5.2-final, March 18, 2016

[Leo](http://leoeditor.com/) 5.2-final is now available on [SourceForge](http://sourceforge.net/projects/leo/files/Leo/). Leo is a PIM, an IDE and an outliner.

**The highlights of Leo 5.2**

- Easy install with PyInstaller packaging
- c.cloneFindByPredicate
- clone-find-marked commands
- decorators create all Leo commands
- find-def and find-var
- help-for-keystroke
- The --ipyhon command-line option works with latest IPython versions
- Optional line numbers in the body pane
- show-invisibles uses Qt characters
- Themes
- Wildcard file names on Leo's command line

**Links**

[Leo's home page](http://leoeditor.com)
[Documentation](http://leoeditor.com/leo_toc.html)
[Tutorials](http://leoeditor.com/tutorial.html)
[Video tutorials](http://leoeditor.com/screencasts.html)
[Forum](http://groups.google.com/group/leo-editor)
[Download](http://sourceforge.net/projects/leo/files/)
[Leo on Github](https://github.com/leo-editor/leo-editor)
[What people are saying about Leo](http://leoeditor.com/testimonials.html)
[A web page that displays .leo files](http://leoeditor.com/load-leo.html)
[More links](http://leoeditor.com/leoLinks.html)
</t>
<t tx="ekr.20160314155002.10">https://github.com/leo-editor/leo-editor/issues/182

Added g.splitLongFileName and called it from several file dialogs.
</t>
<t tx="ekr.20160314155002.11">https://github.com/leo-editor/leo-editor/issues/193

The fix was in GoToLineNumber.go: it must test for p.isAtCleanNode()
</t>
<t tx="ekr.20160314155002.12">https://github.com/leo-editor/leo-editor/issues/195

1. p.textOffset returns None if no @&lt;file&gt; node is an ancestor.
2. p.textOffset never caches its result.
    In any case, it was quite wrong to cache results in positions.
3. Rewrote p.textOffset to simplify it.
4. QtStatusLineClass.update prints '' for fcol if p.textOffset returns None.
5. Changed unit tests accordingly.
</t>
<t tx="ekr.20160314155002.13">https://github.com/leo-editor/leo-editor/issues/196

The fix was to use setBackground instead of setBackgroundColor.
No real testing was done.
</t>
<t tx="ekr.20160314155002.14">https://github.com/leo-editor/leo-editor/issues/198
</t>
<t tx="ekr.20160314155002.15">https://github.com/leo-editor/leo-editor/issues/199

Leo now warns in the log pane and raises a summary dialog about possibly already-open files.  However, all files are opened as usual, leaving it to the user to determine what to do.

A (new?) bug *won't* be fixed.  Closing a file removes the file's entry from g.app.db, so reopening the file *again* won't give another warning.  This is a very minor matter.

What I did: (See app.Detecting already-open files)

- Added g.app.already_open_files list.
- Added calls to new runAlreadyOpenDialog method in c.open and LM.doPostPluginsInit.
- Rewrote app.checkForOpenFile.
</t>
<t tx="ekr.20160314155002.16">https://github.com/leo-editor/leo-editor/issues/200

- Added leo.commands.gotoCommands module.
- Removed almost all old code.
- Added goto.get_external_file_with_sentinels.
  This returns the external file *with* sentinels, even if
  it normally does not have sentinels.
- Added goto.scan_nonsentinel_lines &amp; goto.scan_sentinel_lines.
  These contain the essential algorithms.
- Added code to force any particular write to use sentinels.
</t>
<t tx="ekr.20160314155002.17">https://github.com/leo-editor/leo-editor/issues/211
</t>
<t tx="ekr.20160314155002.18">https://github.com/leo-editor/leo-editor/issues/213

The fix was so simple: just use default arguments to connect_qtconsole.

The preliminaries were at least as important as the fix itself:

1. Modernized the imports, removing support for legacy imports. Imo, it would be unwise to support ancient code now.

2. Added logging methods. This makes it possible to understand and debug the code in leoIPython.py. Furthermore...

3. Leo's --debug option enables more verbose IPython logging. This is a feature that reveals the workings of the Jupyter kernel.
</t>
<t tx="ekr.20160314155002.19">https://github.com/leo-editor/leo-editor/issues/215
</t>
<t tx="ekr.20160314155002.2">- c.cloneFindByPredicate
- clone-find-marked commands:
  cfam (clone-find-all-marked)
  cffm (clone-find-all-flattened-marked)
- decorators create all Leo commands
- declutter headlines: icons replace @file, @clean, etc.
- find-def and find-var
- help-for-keystroke
- Optional line numbers in the left gutter
- show-invisibles uses Qt characters
- The --ipyhon command-line option works with latest IPython versions
- Themes
- Wildcard file names on Leo's command line
</t>
<t tx="ekr.20160314155002.20">https://github.com/leo-editor/leo-editor/issues/217
</t>
<t tx="ekr.20160314155002.21">https://github.com/leo-editor/leo-editor/issues/218

Here's a shell script you can run in a console

https://gist.github.com/tbnorth/4b781ba2b8f59c83dd5e

to show the content of the primary and secondary selections, and the
clip-board.  You'll probably need to install xclip

When the mouse is released after drag-selecting text in Leo, the
primary selection updates as expected.  This doesn't happen with
shift-arrow selection.

It looks like keyboard shift-arrow selection should call
QClipboard::setText(const QString &amp; text, Mode mode = QClipboard::Selection)
</t>
<t tx="ekr.20160314155002.22">https://github.com/leo-editor/leo-editor/issues/220

Executing clone-to-at-spot with an @spot node selected causes Leo to become
unresponsive and python process slowly eats up all system memory.
</t>
<t tx="ekr.20160314155002.23">https://github.com/leo-editor/leo-editor/issues/224

The fix was in c.checkGnxs
</t>
<t tx="ekr.20160314155002.24">https://github.com/leo-editor/leo-editor/issues/234
</t>
<t tx="ekr.20160314155002.25">https://github.com/leo-editor/leo-editor/issues/239
</t>
<t tx="ekr.20160314155002.26">Using c.tab_width is wrong: it is the *default* tab width.

Created c.getTabWidth()
</t>
<t tx="ekr.20160314155002.27">Rev 645b4ec2f9. Here is the checkin log:

Fixed a bug in p.__eq__, introduced at rev d0dd25b7b (2015-11-14 18:37:06).

p.__eq__ must *not* return NotImplemented when p2 is None.
</t>
<t tx="ekr.20160314155002.28">The fixes were in abbrev.expandAbbrev and helpers.

Rev 585d2f4 improves abbreviations as follows:

- Match longest prefix first: e;; no longer interferes with date;;
- Predefine 'x' as the empty string before executing abbreviation scripts.
- Split @data abbreviations-subst-env into separate nodes.
- Defined do() and insert() functions in @data abbreviations-subst-env as follows::

**Note**:  Because of a glitch in how abbreviations scripts are created, this won't work::

    do(['command1','command2'])

even though c.k.simulateCommand allows list arguments.  Instead, do this::

    do('command1');do('command2');

The following abbreviations insert matching characters (no need to do x='' in them)::

    (={|{insert('()');do('back-char')}|}
    [={|{insert('[]');do('back-char')}|}
    {={|{insert('{}');do('back-char')}|}

This is an implementation of auto-close-quotes, done entirely with abbreviations! For example, typing '(' inserts '()' and puts the cursor between the parens.

I personally dislike these abbreviations.  I find it harder to skip past the ')' than to type it later.  ymmv.
</t>
<t tx="ekr.20160314155002.29"></t>
<t tx="ekr.20160314155002.3"></t>
<t tx="ekr.20160314155002.30">https://groups.google.com/d/msg/leo-editor/tA5Q2YrEu-w/9mzqFAHMcX4J

The fix was in find.changeSelection.
</t>
<t tx="ekr.20160314155002.31">Rev a7e2e86 fixes atFile.create.
</t>
<t tx="ekr.20160314155002.32">It now works when there is no text selection.
</t>
<t tx="ekr.20160314155002.33">Ctrl-LtArrow and Ctrl-RtArrow leave the cursor at the start of a word.
This is the way most editors work.

The fix was in moveWordHelper.
</t>
<t tx="ekr.20160314155002.34">Leo acts on some operator input when the Leo window is NOT the top window
https://github.com/leo-editor/leo-editor/issues/153

This problem is discussed in the Leo-Editor forum thread:
https://groups.google.com/forum/?fromgroups#!topic/leo-editor/3PPObn4JRik

I can't reliably reproduce this problem, so I can't give you a test case that demonstrates it.

The symptom that I first noticed was unexpected, unpredictable changes in what the tree pane showed when I switched back to Leo-Editor after switching away from Leo-Editor by executing open-url.

Sometimes the node selected was unchanged, but it had been scrolled up in the tree pane; and sometimes it had been scrolled all the way out of the tree pane.

Sometimes the node selected had been changed to a sibling node after the node that was selected when I switched away from Leo-Editor.

In all cases, the body pane correctly showed the contents of the currently selected node.

Sometimes an Alt-F4 when a non-Leo-Editor window is the only window showing, causes Leo-Editor to exit or display its "Save changes before exit?" query.

Edward K. Ream currently believes: "The culprit is likely a delayed action (on the order of 0.5 sec) that Leo takes on focus-in events. If the user responds to a focus-in event before that time there will be problems."

My test system:

Xubuntu32 12.04
Python 2.7.3, PyQt version 4.8.1

The problem has been observed on Leo-Editor commit f6cdb2b. It seems to occur slightly more frequently on more recent commits such as 42a5207.
</t>
<t tx="ekr.20160314155002.35">https://github.com/leo-editor/leo-editor/issues/188

This bug appears to be invalid.
</t>
<t tx="ekr.20160314155002.36">https://github.com/leo-editor/leo-editor/issues/188

Rev e8b134:

Improved reporting of find options.  The report now shows suboutline-only and node-only.
- Just after Ctrl-F the status line contains:

    Find (wixbhacf[esn]): &lt;list of options&gt;

- When the command completes, the status line contains:

    found/not found (&lt;list of options&gt;): &lt;find pattern&gt;

This makes it much easier to see what is going on.

I suspect that #188 is invalid.  These changes will reduce confusion.
</t>
<t tx="ekr.20160314155002.37">https://github.com/leo-editor/leo-editor/issues/232

Appears invalid: only happens on 5.1 final.
</t>
<t tx="ekr.20160314155002.38">The orphan bit was set in @file leoGlobals.py. This prevented the file from
being updated.

Changed:
- at.read.
- at.readAll
- fc.putVnode no longer writes orphan bits.
- Removed warning in at.read about orphan bits.
</t>
<t tx="ekr.20160314155002.39"></t>
<t tx="ekr.20160314155002.4">https://github.com/leo-editor/leo-editor/issues/131

The fix was to replace:

    w = self.editWidget()

by:

    w = c.frame.tree.edit_widget(p)

in editCommands.insertHeadlineTime.
</t>
<t tx="ekr.20160314155002.40">​Recent revs add the following new position methods:

- p.is_at_all():  True if p is an @&lt;file&gt; node containing an @all directive.
- p.in_at_all(): True if p is in an @&lt;file&gt; tree whose root contains @all.
- p.is_at_ignore(): True if p is an @ignore node
- p.in_at_ignore_tree(): True if p is in an @ignore tree.

These predicates make it easy to create other predicates that skip @ignore trees or @&lt;file&gt; trees containing @all.  cffm and cfam do not skip such trees, on the theory that one would typically unmark nodes first before marking nodes to be cloned.

So here is how to gather only those marked nodes that lie outside any @ignore tree:

    def isMarked(p):
        return p.isMarked() and not p.in_at_ignore_tree()

    self.cloneFindByPredicate(
        generator = self.all_unique_positions,
        predicate = isMarked,
        flatten = flatten,
        undoType = 'gather-marked')
</t>
<t tx="ekr.20160314155002.41">Useful for per-file backups.
</t>
<t tx="ekr.20160314155002.42">Traverses the tree given using the generator, cloning all positions for which predicate(p) is True. Undoably moves all clones to a new node, created as the last top-level node.
</t>
<t tx="ekr.20160314155002.43">April 15, 2015

Rev 419a82d changes several aspects of how Leo handles the so-called orphan bit in vnodes.  These are major changes, but I believe they will be for the best.

The orphan bit indicates that there was a problem writing an @&lt;file&gt; node.  It will be set, for example, when an @file node contains children but has no @others directive.  Leo simply cannot write the external file in that case.

However, Leo went overboard with the error logic. Here are the recent changes:

1. Leo no longer writes the orphan bit ('O' bit in vnode attr) in .leo files. This kind of persistent error bit seems unwise.

2. Leo clears the bit and issues a warning when reading a vnode with the 'O' attr.

Previously, Leo would refuse to update the outline from the external file if the orphan bit was set! 

This change could have unforeseen consequences, but I suspect nobody will ever notice.  The foreseen consequence is that Leo will keep the outline and external files in sync more often.
</t>
<t tx="ekr.20160314155002.44">- Defined all commands in leoPlugins.leo with @g.command.

- Eliminate the "cmd_" convention. The g.command decorator now sets func.is_command and func.command_name. Plugin.create_menu is now much simpler.
  
- All decorated commands now use the "event" arg:

    @g.command('command-name')
    def my_command(event=None):
        ...

    @cmd('command-name')
    def my_command(self,event=None):
        ...
</t>
<t tx="ekr.20160314155002.45">This function was a bad idea and was never used.

</t>
<t tx="ekr.20160314155002.46">The leo/commands directory contains the new code.
</t>
<t tx="ekr.20160314155002.47"></t>
<t tx="ekr.20160314155002.48">Examined c.p and c.currentPosition.
</t>
<t tx="ekr.20160314155002.49"></t>
<t tx="ekr.20160314155002.5">Revised some of the code, but probably more work is needed.
</t>
<t tx="ekr.20160314155002.50"></t>
<t tx="ekr.20160314155002.51">Rev 38db98ff improves Leo's existing clone-find commands:

- cff (clone-find-flattened)
- cfa (clone-find-all)

in the following important ways:

1. These commands search the entire outline, regardless of the presently selected node. This is a *huge* improvement--you can start searches anywhere. These commands do honor suboutline-only searches.

2. These commands ignore @ignore trees and any @&lt;file&gt; tree whose root nodes contains an @all directive. No more false matches about nodes in the attic.

3. These commands are significantly faster than before because they search body text in one step.

4. The new command names are short enough that they don't need either key bindings or pre-loaded entries in command history.


These commands are so convenient that they become *temporary*. No need to keep them around. I usually start searches with them instead of Ctrl-F. After I create the clone-find node, I then use Ctrl-F (with the existing find pattern) to search the clone-find results.

This is the pattern I have been looking for. I'm not looking for anything better. Notice, it no longer matters how many clones there are.
</t>
<t tx="ekr.20160314155002.52">Two commands that revolutionize my workflow:

- cffm, aka clone-find-flattened-marked
- cfam, aka clone-find-all-marked

These commands create a "target" node as the last top-level node, and clone all marked nodes under the target node.  cffm makes each marked node a child of the target. cfam does not create a child for marked nodes that are descendants of a marked node.

This makes gathering nodes a snap. Just go through the outline, marking the desired nodes, then execute cfam or cffm.  I prefer cffm because all found nodes appear as direct children of the target. These two commands are much better than auto-moving clones as they are made, as I had intended to do yesterday.

Leo's clone-find and clone-find-marked commands allow me to quickly gather desired nodes without duplicates, *regardless* of how many clones there are in an outline. These commands are the magic bullets for searching that I have wanted for decades.

Please try these commands. They are extremely useful.
</t>
<t tx="ekr.20160314155002.53"></t>
<t tx="ekr.20160314155002.54">This command does the following:

1. Clones the selected node.
2. Moves the clone to the last child of the last @spot node in the outline.
3. Collapses all nodes in the outline.
4. Selects the newly-cloned node, thereby making it visible.


</t>
<t tx="ekr.20160314155002.55">Ctrl-x &amp; Ctrl-C cut/copy the entire line if no text is selected
</t>
<t tx="ekr.20160314155002.56">Pretty much like clone-find-all.
</t>
<t tx="ekr.20160314155002.57">Leo now supports find-def and find-var commands.  They find the definitions of classes, defs or vars. These commands work as follows:

- Select the word at the cursor, if text is not already selected.
- Save the find settings in effect before the command started.
- find-def sets the search pattern to "class word" or "def word"
  depending on whether word is capitalized.
- find-var sets the search pattern to "word =".
- Set word-find to True
- Start the search at the root position of the outline.

This finds the first definition of the word.  Thereafter, you can use F3 (find-next) to find additional definitions.

When the search fails, Leo restores the Find settings to what they were previously.

The new @bool find-ignore-duplicates setting (default False), controls whether any search command ignores duplicate matches.  Ctrl-F restarts searches, clearing a list of vnodes that have already been seen.  Any failed search also clears the list of vnodes.
</t>
<t tx="ekr.20160314155002.58"></t>
<t tx="ekr.20160314155002.59">Tells the command name or names associated with any keystroke.

Prompts for a single character: shows corresponding command.
</t>
<t tx="ekr.20160314155002.6">https://github.com/leo-editor/leo-editor/issues/150

The bug was a typo in plugins/importers/basescanner.py.

Also improved reporting in the RecursiveImportController class.
</t>
<t tx="ekr.20160314155002.60">All kill commands except the kill-paragraph and backward-kill-paragraph commands cuts selected *text* if it exists.
</t>
<t tx="ekr.20160314155002.61">The result is much better looking than before.</t>
<t tx="ekr.20160314155002.62">https://github.com/leo-editor/leo-editor/issues/165
All the changes were to the ExternalFilesController class.
</t>
<t tx="ekr.20160314155002.63"></t>
<t tx="ekr.20160314155002.64">These directives are inherited as usual.
</t>
<t tx="ekr.20160314155002.65">Leo now immediately wraps the body pane when @wrap is in effect.
Previously, the user had to reselect the node when typing "@wrap". This
fixes an annoying hangnail.

- Added match_at_wrap to jEdit colorizers.
- Added force keyword option to all setWrap methods.
  This is needed because text can be colorized before c.p.b stabilizes.
</t>
<t tx="ekr.20160314155002.66"></t>
<t tx="ekr.20160314155002.67">To enable, add the following to myLeoSettings.leo:

    @bool tree-declutter = True

    @data tree-declutter-patterns
    
LeoSettings.leo contains an example @data tree-declutter-patterns.
This node contains documentation about how to use the patterns.
</t>
<t tx="ekr.20160314155002.68">https://groups.google.com/d/msg/leo-editor/yJLz-p3I4mY/Pqa1phYN_10J
</t>
<t tx="ekr.20160314155002.69">leoSettings.leo now contains a new top-level node::

    @ignore Themes: copy to last top-level setting in myLeoSettings.leo

The body text tells what to do with it, namely:

To enable a theme:

1. Copy this entire tree to myLeoSettings.leo.
2. Move the tree so it is the last top-level node under @settings.
3. Remove the @ignore from the copy of this node.
4. Enable one of the three themes below by removing @ignore for its node.
5. Test by opening another Leo outline.

Important Notes

1. The "Themes" node does not define @data qt-gui-plugin-style-sheet.

Instead the new themes machinery uses the so-called "fully parameterized" stylesheet that we have all been using for at least several months now.  This stylesheet is defined as a descendant of the "Appearance" node.

2. The only functional theme is a new ekr_dark theme.  It illustrates how to use the new themes machinery.

- This theme uses a small, custom @data qt-gui-user-style-sheet that adjust colors around outline indicators.

- There is a tree call "Common to all themes" which contains settings that probably can be shared by most themes.  Naturally, setting in that tree can be overridden as you desire.

3. The new themes machinery is supposed to be completely self contained.  That is, there should be no need to use a script to generate a theme.

Yes, the user must fill in all appearance-related settings.  But most users will already have done this, so adjusting the settings for a theme should be straightforward.

4. The "Common to all themes" node contains an "Outline indicators" node that specifies a relative path to outline indicator icons (arrow icons or plus/minus) icons.  The path can be relative to either the users home directory or (as shown in leoSettings.leo) relative to the leo/Icons directory. 
</t>
<t tx="ekr.20160314155002.7">https://github.com/leo-editor/leo-editor/issues/162

cm.isValidLanguage accepts any language x for which leo/modes/X.py exists.

Added a script in LeoDocs.leo that will generate all valid languages.
</t>
<t tx="ekr.20160314155002.70">Like leo leo\test\*.leo.
Previously, Leo crashed!
</t>
<t tx="ekr.20160314155002.71">Useful after a failed Ctrl-F
</t>
<t tx="ekr.20160314155002.72">https://github.com/leo-editor/leo-editor/issues/177

After a find command completes (successfully or not), the status areas shows:

- Whether the find command completed successfully.
- The find options in effect for the search.

Previously, the status line was only updated for unsuccessful searches, and it did not contain the find options in effect.  The new status line is much more helpful than the old.

By default, Leo reports successful searches with white text on a blue background and failed searches with white text on a red background. These colors work pretty well even for dark themes.

You can choose these colors using the following settings:

     @color find-found-bg = blue
     @color find-found-fg = white
     @color find-not-found-bg = red
     @color find-not-found-fg = white
</t>
<t tx="ekr.20160314155002.73">https://github.com/leo-editor/leo-editor/issues/186

Controlled by the following new settings in leoSettings.leo, with defaults as shown::

    @bool use_gutter = True
    @color gutter-bg = @LightSteelBlue1
    @color gutter-fg = black
    @int gutter-w-adjust = 12
    @int gutter-y-adjust = 10
    @string gutter-font-family = @font-family
    @string gutter-font-size = @small-font-size
    @string gutter-font-style = @font-style
    @string gutter-font-weight = @font-weight
</t>
<t tx="ekr.20160314155002.74">Better looking than the old way.
</t>
<t tx="ekr.20160314155002.75"></t>
<t tx="ekr.20160314155002.76">https://groups.google.com/d/msg/leo-editor/pM8aVJ1D6ao/Z8lq43t7FAAJ

There's now an "Edit settings" menu under the main Settings menu, containing many submenus.  Each menu item finds the appropriate setting and copies it to
the appropriate outline for you, so knowing what to look for and how to
manage it is handled.

Sometimes you'll see this dialog:

    The relevant setting, '@bookmarks_base_color', is using the value of
    a more general setting, '@text-foreground'.  Would you like to edit
    the more specific setting, '@bookmarks_base_color', or the more
    general setting, '@text-foreground'?  The more general setting may
    alter appearance / behavior in more places, which may or may not be
    what you prefer.

                            Edit specific   Edit general   Cancel

Wordy, but easy enough to follow.  I guess everything after the
last comma could be deleted :-)

If the setting is in leoSettings.leo, you see:

    The setting '@body-font-family' is in the Leo global configuration
    file 'leoSettings.leo' and should probably be copied to
    'myLeoSettings.leo' before editing.
    It may make more sense to copy a group or category of settings.

    Please enter 1, 2, 3, or 4:
    1. copy the one setting, '@body-font-family'
    2. copy the setting group, 'Body font' (Recommended)
    3. copy the setting whole category, 'Fonts'
    4. edit the setting in 'leoSettings.leo' anyway

Again, wordy, but I think easy enough to understand.

(Having to enter a number to pick an option is clunky, a
 gui-independent 'pick item from list widget' can be added to Leo, I
 just didn't want to mix that task into the current task.)

Note "Reload settings" isn't working as effectively as I think it
should, that may need to be addressed as well.  Unrelated to the new
code.

So, this isn't a silver bullet for the newbie setting editing woes, but
it does eliminate a lot of the Leo specific knowledge required (apart
from "edit a headline").  Also this new approach can be developed
further based on feedback, just wanted to get what I had so far into
the main branch for testing etc.
</t>
<t tx="ekr.20160314155002.77"></t>
<t tx="ekr.20160314155002.78"></t>
<t tx="ekr.20160314155002.79"></t>
<t tx="ekr.20160314155002.8">https://github.com/leo-editor/leo-editor/issues/169

The fix was a special case in at.readStartNode.
</t>
<t tx="ekr.20160314155002.80">https://groups.google.com/d/msg/leo-editor/wWWUgfDhPi4/VmRRRa_xDAAJ

Terry Brown: I've added remote code execution abilities to mod_http.py  Relevant part of the doc.s pasted below.

This is a plus for a couple of reasons - previously you had to use the leoremote plug-in which used sockets and was really python only, this new approach just uses HTTP GET requests which can be generated by almost anything (language, link in a doc., browser bookmark, etc.). Also leoremote doesn't work in Python 3.x.

This code to load a file into Leo from the command line:
https://github.com/leo-editor/snippets/blob/master/utils/led.py

Can be replaced with this version:
https://github.com/leo-editor/snippets/blob/master/utils/led.sh

Executing code remotely
-----------------------

.. warning::

    Allowing remote code execution is a **HUGE SECURITY HOLE**, you need to be sure that the url from which you access Leo (typically http://localhost:8130/) is accessible only by people and software you trust.

    Remote execution is turned off by default, you need to manually / locally change the @setting ``@bool http_allow_remote_exec = False`` to ``True`` to enable it.

Commands to be executed are submitted via HTTP GET requests, which can be generated in almost any language and also triggered from shortcuts, links in other documents or applications, etc. etc.

The basic form is::

    http://localhost:8130/_/exec/?cmd=&lt;python code for Leo to execute&gt;

The query parameters are:

``cmd`` (required)
    A valid python snippet for Leo to execute.  Executed by the ``vs-eval`` command in the ``valuespace`` plug-in.  Can be specified multiple times, each is executed in order.  May contain newlines, see examples.
    
``c`` (optional)
    Which currently loaded outline to use, can be an integer, starting from zero, or the full path+filename, or just the base filename. Defaults to 0 (zero), i.e. the "first" open outline.
    
``enc`` (optional)
    Encoding for response, 'str', 'repr', or 'json'.  Used to render the returned value.
    
``mime_type`` (optional)
    Defaults to ``text/plain``.  Could be useful to use ``text/html`` etc.

A special variant url is::

    http://localhost:8130/_/exec/commanders/

which returns a list of open outlines.

Examples
========

This command::

    curl http://localhost:8130/_/exec/?cmd='c.bringToFront()' &gt;/dev/null

will raise the Leo window, or at least make the window manager signal the
need to raise it.

::

    curl --get --data-urlencode \
      cmd='g.handleUrl("file:///home/tbrown/.leo/.contacts.leo#Contacts", c)' \
      http://localhost:8130/_/exec/ &gt;/dev/null

will cause a running Leo instance to open ``/some/path/contacts.leo`` and select the ``Contacts`` node.  A desktop icon link, browser bookmark, or link in a spread-sheet or other document could be used the same way.

In the ``bash`` shell language, this code::

    TEXT="$@"
    curl --silent --show-error --get --data-urlencode cmd="
        nd = c.rootPosition().insertAfter()
        nd.h = 'TODO: $TEXT'
        import time
        nd.b = '# created %s' % time.asctime()
        c.selectPosition(nd)
        c.redraw()
        'To do item created\n'
    " http://localhost:8130/_/exec/

could be written in a file called ``td``, and then, assuming that file is executable and on the shell's path, entering::

    td remember to vacuum the cat

on the command line would create a node at the top of the first open outline in Leo with a headline ``TODO: remember to vacuum the cat`` and a body text ``# created Wed Jul 29 16:42:26 2015``. The command ``vs-eval`` returns the value of the last expression in a block, so the trailing ``'To do item created\n'`` gives better feedback than ``None`` generated by ``c.redraw()``. ``c.selectPosition(nd)`` is important ant to stop Leo getting confused about which node is selected.
</t>
<t tx="ekr.20160314155002.81"></t>
<t tx="ekr.20160314155002.82">The make_stub_files script eliminates much of the drudgery of creating python stub (.pyi) files https://www.python.org/dev/peps/pep-0484/#stub-files from python source files.

The script does no type inference. Instead, it creates function annotations using user-supplied **patterns**, pairs of strings of the form "name: type-annotation".

Full code and documentation here: https://github.com/edreamleo/make-stub-files
</t>
<t tx="ekr.20160314155002.83">This script helps Python programmers convert Python code to coffeescript. It converts python syntax to the roughly equivalent coffeescript syntax.

This script makes a coffeescript (.coffee) file in the output directory for each source file listed on the command line (wildcard file names are supported).

Full code and documentation here: https://github.com/edreamleo/python-to-coffeescript

Note: This script resulted in the TokenSync class, now in leoAst.py.</t>
<t tx="ekr.20160314155002.84"></t>
<t tx="ekr.20160314155002.85">This setting controls whether any search command ignores duplicate matches.  Ctrl-F restarts searches, clearing a list of vnodes that have already been seen.  Any failed search also clears the list of vnodes.
</t>
<t tx="ekr.20160314155002.86">When True, find commands get their find pattern from the word under the cursor.
</t>
<t tx="ekr.20160314155002.87">True: syntax errors raise impossible-to-miss popup dialog.
</t>
<t tx="ekr.20160314155002.88">Enable with: @bool use_find_dialog = True
Related setting: @bool close-find-dialog-after-search = False

Defaults are as shown above.
</t>
<t tx="ekr.20160314155002.89">The following settings set the colors in the status line after a search completes:

    @color find-found-bg = blue
    @color find-found-fg = white
    @color find-not-found-bg = red
    @color find-not-found-fg = white
</t>
<t tx="ekr.20160314155002.9">https://github.com/leo-editor/leo-editor/issues/181

LM.finishOpen now calls c.outerUpdate.
</t>
<t tx="ekr.20160314155002.90">The fix was to create a dummy root position in abbrev.init_env.
</t>
<t tx="ekr.20160314155002.91">If you aren't using the @data history-list setting chances are that you missing a big chance to simplify your workflow. At one time I thought the history list was a minor feature.  I could not have been more wrong.

The body of the @data history-list node should contain a list of command names, one per line.  This list can include commands created by @command/@button nodes.

You execute items in the history list by doing Alt-X followed by an up arrow to get the first item in the list, or one or more down arrows to get later items in the list.  The last item you execute from this list goes to the head of the list.  Once you have executed an item, Ctrl-P (repeat complex command) will re-execute it.

The history list works well for commands that aren't quite worth a separate key binding, but that nevertheless you find you using quite often.

Even better, the history list is a perfect complement to @button and @command nodes that are tailored for a particular outline. For example, there is a button called cfa-code in leoPy.leo that executes the clone-find-all-flattened command starting at the top-level "Code" node.
</t>
<t tx="ekr.20160314155002.92">https://github.com/leo-editor/leo-editor/issues/183

Added @ignore @data qt-gui-user-style-sheet to leoSettings.leo.
This contains  alternative active pane highlighting.

This completes enhancement #183: improve focus-border handling in qt stylesheet
https://github.com/leo-editor/leo-editor/issues/183

It would be tricky, and not terribly useful, to fold this user stylesheet into
the main @data qt-gui-plugin-style-sheet, especially considering that
themes may want to use qt-gui-user-style-sheet.

Also, the default settings aren't bad, but I prefer to change qt-gui-user-style-sheet directly.
</t>
<t tx="ekr.20160314155002.93">Here are the details:

@ifenv name, one-or-more-comma-separated values

Includes descendant settings if os.getenv(name) matches any of the values.

- Case is significant in the *name* of the environment variable.
- Case is ignored in the *values*.

Examples:

@ifenv HOSTNAME,bob
    Enables descendant settings if os.environ('HOSTNAME') is 'Bob' or 'bob'

@ifenv EDITOR,leo,lion
    Enables descendant settings if os.environ('Editor') is 'Leo' or 'Lion', etc.

@ifplatform name,  one-or-more-comma-separated values.

Includes descendant settings if sys.platform matches any of the values, ignoring case.

Examples:

@ifplatform darwin,linux2
    Enables descendant settings for MacOS and Linux.

@ifplatform win32
    Enables descendant settings for Windows

@ifhostname name

Includes descendant settings if os.environ('HOSTNAME') == name

@ifhostname !name

Includes descendant settings if os.environ('HOSTNAME') != name
</t>
<t tx="ekr.20160314155002.94"></t>
<t tx="ekr.20160314155002.95">@bool use_gutter = True
@color gutter-bg = @LightSteelBlue1
@color gutter-fg = black
@int gutter-w-adjust = 12
@int gutter-y-adjust = 10
@string gutter-font-family = @font-family
@string gutter-font-size = @small-font-size
@string gutter-font-style = @font-style
@string gutter-font-weight = @font-weight
</t>
<t tx="ekr.20160314155303.1"></t>
<t tx="ekr.20160315105606.1"></t>
<t tx="ekr.20160428153901.1">Leo 5.3-final May 2, 2016

[Leo](http://leoeditor.com/) 5.3-final is now available on [SourceForge](http://sourceforge.net/projects/leo/files/Leo/). Leo is a PIM, an IDE and an outliner.

**The highlights of Leo 5.3**

- Leo now supports Jupyter Notebook (.ipynb) files.
- @chapter is now allowed anywhere. No need for @chapters.
- Faster spell checking.
- The rst3 command supports @rst-table.
- The show-invisibles command now uses native Qt characters.
- Dozens of other improvements and bug fixes.

**Leo is**:

- An outliner. Everything in Leo is an outline.
- A Personal Information Manager.
- A browser with a memory.
- A powerful scripting environment.
- A tool for studying other people's code.
- A fully-featured IDE, with emacs-like commands.
- Extensible via a simple plugin architecture.
- A tool that plays well with  IPython, vim and xemacs.
- Written in 100% pure Python
- Compatible with Python 2.6 and above or Python 3.0 and above.
- A tool with an inspiring and active community.

**Leo's unique features**:
    
- Always-present, persistent, outline structure.
- Leo's underlying data is a Directed Acyclic Graph.
- Clones create multiple views of an outline.
- A simple, powerful, outline-oriented Python API.
- Scripts and programs can be composed from outlines.
- Importers convert flat text into outlines.
- Scripts have full access to all of Leo's sources.
- Commands that act on outline structure.
  Example: the rst3 command converts outlines to reStructuredText.
- @test and @suite scripts create unit tests automatically.
- @button scripts apply scripts to outline data.
- Outline-oriented directives.

Simulating these features in vim or Emacs is possible, just as
it is possible to simulate Python in assembly language...

**Links**

- [Leo's home page](http://leoeditor.com)
- [Documentation](http://leoeditor.com/leo_toc.html)
- [Tutorials](http://leoeditor.com/tutorial.html)
- [Video tutorials](http://leoeditor.com/screencasts.html)
- [Forum](http://groups.google.com/group/leo-editor)
- [Download](http://sourceforge.net/projects/leo/files/)
- [Leo on Github](https://github.com/leo-editor/leo-editor)
- [What people are saying about Leo](http://leoeditor.com/testimonials.html)
- [A web page that displays .leo files](http://leoeditor.com/load-leo.html)
- [More links](http://leoeditor.com/leoLinks.html)
</t>
<t tx="ekr.20160501153808.1">- Install pyenchant. (spelling)
- Install meta (livecode plugin)
- Downinstall setuptools:
    - Erase setuptools stuff from Lib/sitecustomize.
    - pip2/3 install setuptools==19.2
</t>
<t tx="ekr.20161015091350.1">- Make sure no distributed .leo file contains xml-stylesheet elements.
  Run @button check .leo files in leo-dist.leo.
- Make sure Leo looks good without myLeoSettings.leo.
- Run the "check-bindings" button in leoSettings.leo.
- Run all unit tests with *both* Python 2 and 3.
- Run ll -a with *both* Python 2 and 3.</t>
<t tx="ekr.20161015091353.1">- Regenerate all .html files.
- Copy files to web, including leo/doc/html/index.html</t>
<t tx="ekr.20161015091353.2">LeoDocs.leo:
- Make sure copyright dates are correct.
- Update the "last updated" text in index.html.
- Update version numbers in html/conf.py
- Update the release notes.
- Remove @language rest where possible in new notes.
- Create new "what's new" section.
- Remove top-level clones.
- Spell check entire file.
- Copy release notes to leoDist.leo.
- Copy release notes to LeoReleaseNotes.leo
- Select the readme node.

LeoDist.leo:
- Make sure copyright dates are correct.
- Update version numbers: search leoDist.leo for ##version.
- Update readme.md.
- Check readme.md spelling.
- Check 'PKG-INFO.TXT'

leoVersion.py:
- Update version constant.

LeoPyRef.leo and LeoPluginsRef.leo:
- Regenerate from corresponding local file.
- Remove top-level clones.
</t>
<t tx="ekr.20161015091353.3">- Update the *GitHub* release at https://github.com/leo-editor/leo-editor/releases
   This must be done *soon* after the release's actual commit.
   There is a "Draft New Release" button at the top-right of the page.

- Update version number on Leo's wikipedia site:
  http://en.wikipedia.org/wiki/Leo_%28editor%29
  - Edit with the 'Edit this page' *tab* (not a link)
  - Update version number on web site.

- Announce to SourceForge:  http://sourceforge.net/projects/leo/
   **Markdown accepted, so paste release notes in LeoDocs.leo.**.

- Announce to leo-editor: **Paste source-forge announcement**.

- Announce to Python-announce-list using email:
   mailto:python-announce-list@python.org
   **Paste source-forge or leo-editor announcement**.

  - Check it by visiting the archive:
  https://mail.python.org/pipermail/python-announce-list/

- Register Leo at https://pypi.python.org/pypi/leo

- My blog: http://edreamleo.blogspot.com/
  **Paste source-forge or leo-editor announcement**.
  **To get HTML, just use html tab**.

- Twitter (point to my blog)
</t>
<t tx="ekr.20161015092224.1">Run make-leo.
- Commit all files before running make-leo.
- Run make-leo button in leoDist.leo.
- Commit any changed files.
- If any files change, rerun make-leo.

Create the executable installer:
- Double-click leo.nsi. (Run with makeNSIS.exe)

Run pyinstaller on Windows:
- (optional) Delete leo-editor/dist and leo-editor/build folders.
- Run [a32]&gt; pyinstaller --clean --win-private-assemblies launchLeo-unified.spec
- Test a *copy* of the result so .pyo files are not added to the package)
- ***Rename** leo/dist/LeoAppFolder to LeoApp (fixes windows naming problem).
- Compress the LeoApp folder to Leo_&lt;version&gt;_Win.zip.
    
Run pyinstaller on Linux:
- (optional) Delete leo-editor/dist and leo-editor/build folders.
- Run pyinstaller2 launchLeo-unified.spec
- Test a *copy* of the result so .pyo files are not added to the package)
- Compress the folder to Leo_&lt;version&gt;_Linux_64_bit.tar.gz.
</t>
<t tx="ekr.20161015114905.1">Leo 5.4-final   October 22, 2016

[Leo](http://leoeditor.com/) 5.4 is now available on [SourceForge](http://sourceforge.net/projects/leo/files/Leo/). 

Leo is an IDE, outliner and PIM, as described [here] (http://leoeditor.com/preface.html).

Simulating Leo's features in Vim, Emacs or Eclipse is possible, just as it is possible to simulate Python in assembly language...

**The highlights of Leo 5.4**

- Added clone-find commands, a new way to use Leo.
- The clone-find and tag-all-children commands unify clones and tags.
- The new pyflakes and flake8 make it possible to check files from within Leo.
- Added importers for freemind, mindjet, json and coffeescript files.
- Rewrote the javascript importer.
- Imported files can optionally contain section references.
- The viewrendered plugin supports @pyplot nodes.
- Improved the mod_http plugin.
- @chapter trees need no longer be children of @chapters nodes.
- All known bugs have been fixed.

**Links**

- [Leo's home page](http://leoeditor.com)
- [Documentation](http://leoeditor.com/leo_toc.html)
- [Tutorials](http://leoeditor.com/tutorial.html)
- [Video tutorials](http://leoeditor.com/screencasts.html)
- [Forum](http://groups.google.com/group/leo-editor)
- [Download](http://sourceforge.net/projects/leo/files/)
- [Leo on GitHub](https://github.com/leo-editor/leo-editor)
- [What people are saying about Leo](http://leoeditor.com/testimonials.html)
- [A web page that displays .leo files](http://leoeditor.com/load-leo.html)
- [More links](http://leoeditor.com/leoLinks.html)
</t>
<t tx="ekr.20161017070909.1">def remove_commit_timestamp_json(self):
    '''Remove leo/core/commit_timestamp.json.'''
    path = g.os_path_finalize_join(
        g.app.loadDir, '..', 'core', 'commit_timestamp.json')
    if g.os_path_exists(path):
        os.remove(path)
    else:
        g.trace('not found', path)
</t>
<t tx="ekr.20161020040946.1">Test files in installed folder:

- Run all unit tests in the installed folder, with the installed Leo.

- Make sure the following open without errors:
    - leoPlugins.leo
    - leoPy.leo
    - LeoDocs.leo
</t>
<t tx="ekr.20161020041000.1">Create a git tag **last**

- Create a full (annotated) tag: do not use the -f option.

    git tag -a 5.xxx -m "Added 5.xxx tag"
    git push --follow-tags
</t>
<t tx="ekr.20161024113526.1">@language rest
@wrap
</t>
<t tx="ekr.20161024113542.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/106

How to Create and Maintain a Tap
https://github.com/Homebrew/brew/blob/master/docs/How-to-Create-and-Maintain-a-Tap.md

How To Open a Homebrew Pull Request (and get it merged)
https://github.com/Homebrew/brew/blob/master/docs/How-To-Open-a-Homebrew-Pull-Request-(and-get-it-merged).md
</t>
<t tx="ekr.20161024113553.1">From: Winn Dixie incredible0n3@gmail.com

Would be stellar to have a brew install leo. http://brew.sh/

Homebrew formulae are simple Ruby scripts::

require "formula"

class Wget &lt; Formula
  homepage "http://www.gnu.org/software/wget/"
  url "http://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz"
  sha1 "f3c925f19dfe5ed386daae4f339175c108c50574"

  def install
    system "./configure", "--prefix=#{prefix}"
    system "make", "install"
  end
end

To install homebrew, paste this in a terminal::

ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"

The script explains what it will do and then pauses before it does it.
</t>
<t tx="ekr.20161024113810.1">https://github.com/ludwigschwardt

I've made a first draft of this many moons ago (1 Oct 2013, to be exact :-)).

It still installs Leo 4.10 final. That is if it still works, as I haven't tested it in a while...

You can try it out like this from my tap:

brew tap ska-sa/tap
brew install leo

You are more than welcome to copy it from [here](https://github.com/ska-sa/homebrew-tap/blob/master/leo.rb) and tinker with it.
</t>
<t tx="ekr.20161024114150.1">Whew. Added this pull request: https://github.com/Homebrew/legacy-homebrew/pull/38980
We'll see what happens...

Here is the updated leo.rb file that passes brew audit --strict Leo:

@language ruby

class Leo &lt; Formula
  homepage "http://leoeditor.com/"
  url "https://downloads.sourceforge.net/projects/leo/files/Leo/5.1-final/Leo-5.1-final.zip"
  sha256 "2d742f9825959ba5c7624d1179b9f3065e14e055c90272fbce199f91770de826"

  depends_on "pyqt"
  depends_on "enchant" =&gt; :recommended

  def install
    # Obtain information on Python installation
    python_xy = "python" + `%x(python -c "import sys;print(sys.version[:3])")`.chomp
    python_site_packages = lib + "#{python_xy}/site-packages"
    python_site_packages.install "leo"
    bin.install ["launchLeo.py", "profileLeo.py"]
    ln_s "#{bin}/launchLeo.py", "#{bin}/leo"
  end

  test do
    # Create, run in and delete a temporary directory.
    if system "python" "-c" "import leo"
      onoe "Leo FAILED"
    else
      ohai "Leo OK"
    end
  end
end

@language rest

It took quite awhile to grok what was going on. Here are my notes:

brew update
  # updates formulae.
brew doctor
# Clone homebrew into ~/leo.repo/homebrew
cd ~/leo.repo
git clone https://github.com/leo-editor/homebrew.git
brew create http://sourceforge.net/projects/leo/files/Leo/5.1-final/Leo-5.1-final.zip
    # This Downloaded the file and opened vim:
    # ==&gt; Downloading http://sourceforge.net/projects/leo/files/Leo/5.1-final/Leo-5.1-
    # The second time I did this I simply replaced the file with the proper leo.rb.
brew audit --strict Leo
  # Caught various problems.
cd homebrew
  # Not part of the instructions.
git checkout -b Leo
  # Switched to a new branch 'Homebrew-Leo'
git add Library/Formula/leo.rb
  # Not part of the instructions.
git commit Library/Formula/leo.rb ### &amp;&amp; git push
git push
  # (within SourceTree) using my normal GitHub username and password.

</t>
<t tx="ekr.20161024115114.1">Here is the latest leo.rb:

@language ruby

class Leo &lt; Formula
  homepage "http://leoeditor.com/"
  url "http://sourceforge.net/projects/leo/files/Leo/5.0-final/Leo-5.0-final.zip"
  sha256 "2d742f9825959ba5c7624d1179b9f3065e14e055c90272fbce199f91770de826"
  head "https://github.com/leo-editor/leo-editor", :using =&gt; :git

  depends_on "pyqt"
  depends_on "enchant" =&gt; :recommended
  depends_on :python if MacOS.version &lt;= :snow_leopard

  def install
    (lib+"python2.7/site-packages").install "leo"
    bin.install "launchLeo.py" =&gt; "leo"
  end

  test do
    system bin/"python", "-c", "import leo"
  end
end

@language rest


This passes the following::

    brew audit --strict Leo
    brew install --verbose --debug Leo

However, after:

    brew uninstall Leo
    brew install Leo

I get the following:

    sh: -c: line 0: syntax error near unexpected token `python'
    sh: -c: line 0: `%x(python -c "import sys;print(sys.version[:3])")'

This looks like an old version of leo.rb is being used, but a thorough search shows no such file. Any help would be appreciated.</t>
<t tx="ekr.20161024115257.1">*Note*: Brew create now computes the hash automatically.

http://stackoverflow.com/questions/32673943/how-to-update-homebrew-sha256

After editing the formula, you can run:

    brew fetch your-formula --build-from-source

to fetch the tarball and display the new checksum.

If you've already downloaded the tarball somewhere, you can calculate the hash with:

    openssl sha256 &lt; some_tarball.tar.gz

or:

    shasum -a 256 some_tarball.tar.gz
</t>
<t tx="ekr.20161025091538.1">Here, I'd like to add to the previous post, to show the big picture. Creating a pull request is actually pretty simple, as the homebrew readme suggests:

1. Fork Homebrew.
2. brew create http://example.com/foo-0.1.tar.gz
3. git checkout -b foo
4. git commit Library/Formula/foo.rb &amp;&amp; git push
5. Pull Request: links to https://github.com/Homebrew/homebrew/pulls

This kind of abbreviated list strikes a good balance for those who know the big picture. But for those who don't, a few more details would be helpful:

Directories

The instructions don't mention directories, which was confusing:

    I forked homebrew in ~/leo.repo, my standard place for repos. This created all kinds of stuff in /usr/local, but those places don't matter. Everything actually should happen in ~/leo.repo/homebrew. It took me awhile to realize I could ignore everything in /usr/local.

    Steps 2, 3 and 4 happened, iirc, in ~/leo.repo or in ~/leo.repo/homebrew, which, in retrospect, makes sense, but did not at the time.

Pushing &amp; the pull request

The following may be blindingly obvious to those with more experience with git, but this was the first time I had used git in a more collaborative way:

    The push happens in my fork, so I can (must) use my own GitHub credentials to do the push. I'm simply modifying my own fork.
    The link in the step 5, pull request, isn't really helpful. Instead, after the push, a button in my fork of homebrew appeared called something like "submit pull request". I pressed the button, added a few comments, and off we went. Next time, I'll add a link to Leo's home page. The email link was redundant, but it may have encouraged the helpful comments that I received...

Changing the pull request

The first pull request had problems, so I assume it won't be pulled. I also assume that I can simply make the changes in leo.rb in my already existing branch, push them, and then issue a new pull request.

Summary: This is actually a straightforward process, but nobody knows better than I that describing a straightforward process is anything but straightforward!
</t>
<t tx="ekr.20161025091621.1">he Formula Cookbook, https://github.com/Homebrew/brew/blob/master/docs/Formula-Cookbook.md, is a must-read, especially the Python-related parts!)

These instructions for contributing to Homebrew (specifically calling brew commands) assume that you are actually *using* Homebrew, and normally the Homebrew repo then lives in /usr/local. I normally work in that repo and would then copy the formula elsewhere for pushing (typically to my tap repo).

You don't have to issue a new pull request. Just add your changes to the same branch and push them, and they will remain associated with the same pull request. This is a great feature of the PR: you can commit and discuss until everyone is happy and the PR then gets accepted.

I would rename the pull request "leo 5.1 (new formula)". :-)
</t>
<t tx="ekr.20161025114433.1"></t>
<t tx="ekr.20161025114444.1">@language ruby

class LeoEditor &lt; Formula
  desc "The Leo IDE/Outliner/PIM"
  homepage "http://leoeditor.com/"
  url "https://github.com/leo-editor/leo-editor/archive/5.4.1.tar.gz"
  sha256 "2cf0f598aa46e8ced6dd7da0229157e7b523704d0a03604a4da14b715c0a232f"

  depends_on :python if MacOS.version &lt;= :snow_leopard
  depends_on "pyqt"
  depends_on "enchant" =&gt; :recommended

  def install
    bin.install "leo"
    bin.install ["launchLeo.py", "profileLeo.py"]
    ln_s "#{bin}/launchLeo.py", "#{bin}/leo"
  end

  test do
    if system "python", "-c", "import", "leo"
      onoe "Leo FAILED"
    else
      ohai "Leo OK"
    end
  end
end</t>
<t tx="ekr.20170316104916.1">- Create Release on SourceForge: http://sourceforge.net/projects/leo/
    - Make sure to upload readme.md and Readme-quick-install.txt.
</t>
<t tx="ekr.20170316113823.1">Leo 5.5 March 23, 2017

[Leo](http://leoeditor.com/) 5.5 is now available on [SourceForge](http://sourceforge.net/projects/leo/files/Leo/) and on [GitHub](https://github.com/leo-editor/leo-editor).

Leo is an IDE, outliner and PIM, as described [here] (http://leoeditor.com/preface.html).

Simulating Leo's features in Vim, Emacs or Eclipse is possible, just as it is possible to simulate Python in assembly language...

**The highlights of Leo 5.5**

- Syntax coloring is 20x faster than before.
  The "big-text" hack is no longer needed.
- Leo's importers are now line/token oriented, allowing them
  to handle languages like javascript more robustly.
- New perl and javascript importers.
- Pylint now runs in the background.
- Pyflakes can optionally check each file as it is written.
- Greatly simplified argument-handling for interactive commands.
- Documented how to do Test-Driven Development in Leo.

**Links**

- [Leo's home page](http://leoeditor.com)
- [Documentation](http://leoeditor.com/leo_toc.html)
- [Tutorials](http://leoeditor.com/tutorial.html)
- [Video tutorials](http://leoeditor.com/screencasts.html)
- [Forum](http://groups.google.com/group/leo-editor)
- [Download](http://sourceforge.net/projects/leo/files/)
- [Leo on GitHub](https://github.com/leo-editor/leo-editor)
- [What people are saying about Leo](http://leoeditor.com/testimonials.html)
- [A web page that displays .leo files](http://leoeditor.com/load-leo.html)
- [More links](http://leoeditor.com/leoLinks.html)
</t>
<t tx="ekr.20170316113823.10">https://github.com/leo-editor/leo-editor/issues/311

Here is the docstring for `k.get1Arg`, which also discusses `k.getNextArg`:

k.get1Arg: Handle the next character the user types when accumulating a user argument from the minibuffer. Ctrl-G will abort this processing at any time.

Commands should use k.get1Arg to get the first minibuffer argument and k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This code will work in any class having a 'c' ivar bound to a commander.
    
**Example 1**: get one argument from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
**Example 2**: get two arguments from the user:
    
    @cmd('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)
            
    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.setLabelBlue('second prompt: ')
        k.getNextArg(handler=self.myCommand2)
        
    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        
k.get1Arg and k.getNextArg are a convenience methods. They simply pass their arguments to the get_arg method of the singleton GetArg instance. This docstring describes k.get1arg and k.getNextArg as if they were the corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n, handler) though they aren't represented that way. When the state machine in the GetArg class is active, the kind is 'getArg'. This constant has special meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    &lt;Return&gt; or (sometimes) &lt;tab&gt;.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.
</t>
<t tx="ekr.20170316113823.11"></t>
<t tx="ekr.20170316113823.12">https://github.com/leo-editor/leo-editor/issues/325
</t>
<t tx="ekr.20170316113823.13">https://github.com/leo-editor/leo-editor/issues/340

Added reload-settings command. This does style-reload automatically.
</t>
<t tx="ekr.20170316113823.14">https://github.com/leo-editor/leo-editor/issues/343
Exception creating path" error when evaluating a path with accents in a @clean expression

The fix was to g.os_path_expandExpression.

</t>
<t tx="ekr.20170316113823.15">https://github.com/leo-editor/leo-editor/issues/344

This setting *was* used: @string view-rendered-default-kind

- Added "use_default" keyword arg to BaseColorizer.scanLanguageDirectives.
- vr.get_kind sets use_default to False, and uses the setting by default.
</t>
<t tx="ekr.20170316113823.16">https://github.com/leo-editor/leo-editor/issues/348
XML CDATA Sections not preserved on round-trip save
</t>
<t tx="ekr.20170316113823.17">https://github.com/leo-editor/leo-editor/issues/350

ssm.expand_css_constants no longer adds constants.
</t>
<t tx="ekr.20170316113823.18">https://github.com/leo-editor/leo-editor/issues/352
Importer unit tests create both @clean and @file

The fix was disappointingly simple: just init ic.treeType in ic.createOutline and ic.scannerUnitTest.
</t>
<t tx="ekr.20170316113823.19">https://github.com/leo-editor/leo-editor/issues/367

createCommonButton now sets the gnx for AtButtonCallback.

QtIconBarClass.goto_command now completes the selection at idle time.
There seems to be no way to do this in one step.

**Note**: ScriptingController.open_gnx uses g.openWithFileName to open settings files.
So the focus problem is pretty strange. 
</t>
<t tx="ekr.20170316113823.2"></t>
<t tx="ekr.20170316113823.20">https://github.com/leo-editor/leo-editor/issues/371

The fix was to extractExecutableString
</t>
<t tx="ekr.20170316113823.21">https://github.com/leo-editor/leo-editor/issues/374
This caused problems in the importers.</t>
<t tx="ekr.20170316113823.22">https://github.com/leo-editor/leo-editor/issues/375
</t>
<t tx="ekr.20170316113823.23">https://github.com/leo-editor/leo-editor/issues/380
New colorizing code doesn't update properly after changing @language directives. 
</t>
<t tx="ekr.20170316113823.24">https://github.com/leo-editor/leo-editor/issues/381

Added g.getEncodingAt(p)</t>
<t tx="ekr.20170316113823.25">https://github.com/leo-editor/leo-editor/issues/387

The problem:

abbrev.init_tree_abbrev changes the outline's changed indicator (*) during startup.
Simply reversing this in c.new causes the * to flip back and forth.

The changes were a bit tricky:
    
- init_tree_abbrev calls c.pasteOutline(...,redrawFlag=False)
- pasteOutline calls c.setChanged(True, redrawFlag=redrawFlag)
- c.new calls c.setChanged(False)
- Added redrawFlag keyword arg to c.setChanged.
  When this is false, c.setChanged does not alter the outline's changed indicator.
  
Suppressing the change indicator is a bit dangerous.
It could be very confusing if the indicator gets out of sync with reality.
But the fix should actually be safe enough, because only startup code is affected.
</t>
<t tx="ekr.20170316113823.26">https://github.com/leo-editor/leo-editor/issues/388</t>
<t tx="ekr.20170316113823.27">https://github.com/leo-editor/leo-editor/issues/389

See the checkin log for details.
</t>
<t tx="ekr.20170316113823.28">https://github.com/leo-editor/leo-editor/issues/391
</t>
<t tx="ekr.20170316113823.29">https://github.com/leo-editor/leo-editor/issues/392
</t>
<t tx="ekr.20170316113823.3">The horrible big text hack is no longer needed.

- Fixes #273: Qt Bug involving large text nodes.

- Completes #365: Use pyzo syntax coloring.

- Revolutionizes Leo's approach to Qt's QSyntaxHighlighter class.  Everything happens automatically. When changing nodes, Leo need only re-init the underlying jEdit colorizing code so that the proper language is colorized. 

No need for any of the interface in the ColorizerMixin class.  No need to "lock out" coloring: it happens automatically whenever Leo's body pane changes! Heh.  As I write this I see that colorizer.colorize is no longer ever called!

I don't think I have ever misunderstood a class as badly as I have misunderstood QSyntaxHighlighter class.  Set up and used properly, it is an amazing helper. To be fair, Leo uses this class in a very unusual manner. The mistake I made was subtle, and the Qt documents don't warn against it.

The performance bug created by calling QSyntaxHighlighter explicitly caused a "series of unfortunate events" ;-) Seeing the speed pyzo's pure python syntax colorer was the key breakthrough.
</t>
<t tx="ekr.20170316113823.30">https://github.com/leo-editor/leo-editor/issues/395</t>
<t tx="ekr.20170316113823.31">https://github.com/leo-editor/leo-editor/issues/396

http://stackoverflow.com/questions/3254652/
several-ways-of-placing-an-image-in-a-qtextedit</t>
<t tx="ekr.20170316113823.32">https://github.com/leo-editor/leo-editor/issues/402

Added g.input_, but this is not a great solution.
</t>
<t tx="ekr.20170316113823.33">https://github.com/leo-editor/leo-editor/issues/403

The fix was to v.atFileNodeName.  It must recognize @thin as an @file node.
</t>
<t tx="ekr.20170316113823.34">c.recursiveImport uncaught exception on broken (linux) symlinks
https://github.com/leo-editor/leo-editor/issues/408
</t>
<t tx="ekr.20170316113823.35">https://github.com/leo-editor/leo-editor/issues/409

The fix was to restore disabled code in jedit.colorRangeWithTag.
</t>
<t tx="ekr.20170316113823.36">https://github.com/leo-editor/leo-editor/issues/416

The fix, as expected, was to k.stroke2char.
</t>
<t tx="ekr.20170316113823.37">https://github.com/leo-editor/leo-editor/issues/426

Added a kludge in dehoistCallback that satisfies k.registerCommand.
</t>
<t tx="ekr.20170316113823.38">https://github.com/leo-editor/leo-editor/issues/427

Fixed #427: multiple vnodes with (same) gnx... All tests pass.

- c.pasteOutline does not call c.checkOutline when tempOutline is True.

Also fixed several tree-drawing problems:

- Refactored abbrev.init_tree_abbrev to suppress unwanted redraws.
- Fixed an unrelated bug in abbrev.paste_tree. It must redraw the tree.
- c.reloadSettingsHelper no longer redraws the tree.
</t>
<t tx="ekr.20170316113823.39">https://github.com/leo-editor/leo-editor/issues/429

- goto.get_external_file_with_sentinels now calls the new g.composeScript.

- Rewrote g.extractExecutableString. It now returns all lines under control of a given language.
</t>
<t tx="ekr.20170316113823.4">Enabled using @bool run-pyflakes-on-write = True
</t>
<t tx="ekr.20170316113823.40">https://github.com/leo-editor/leo-editor/issues/430
rst import: titles with different underline characters on same level.
</t>
<t tx="ekr.20170316113823.41">https://github.com/leo-editor/leo-editor/issues/431

Create importer/writer tables only once, during startup. All tests pass.
This resulted in a cascade of simplifications.

Moved ivars and methods from leoAtFile.py and leoImport.py into the LeoApp class:
- Added atAutoWritersDict, writersDispatchDict, atAutoDict and classDispatchDict ivars.
- Added createAllImporetersData and its two helpers.
- Added scanner_for_at_auto and scanner_for_ext.

leoPersistence.py:
- Moved ConvertController class to the attic.
- Moved pd.convert_at_file_to_at_auto to the attic.
- Moved pd.prepass &amp; helper to the attic.
  As a result, the prepass argument to the importers is no more.
  
leoTest.py:
- All unit tests now restore the screen when done.

leo/plugins/linescanner.py:
- Removed the prepass keyword arg and related logic from i.run.

plugins/qt_frame.py:
- Added a disabled trace to createAtFileNode code, called from the drag/drop logic.
</t>
<t tx="ekr.20170316113823.42">https://github.com/leo-editor/leo-editor/issues/434

Added a guard to fc.parse_leo_file. This is defensive coding.

Changed sf.copy_to_my_settings to reflect recent changes to p.getUnl.
</t>
<t tx="ekr.20170316113823.43">It suffers from mysterious bugs.</t>
<t tx="ekr.20170316113823.44"></t>
<t tx="ekr.20170316113823.45">A recent in doPlainChar change to handle #14 ruined bracket matching.
</t>
<t tx="ekr.20170316113823.46">The proper place to init settings is in write_rst_tree.
rst.rst3 simply inits the file count, n_written
</t>
<t tx="ekr.20170316113823.47"> File "c:\leo.repo\leo-editor\leo\core\leoKeys.py", line 414, in auto_completer_state_handler
    kind), color='red')
TypeError: putStatusLine() got an unexpected keyword argument 'color'
</t>
<t tx="ekr.20170316113823.48"></t>
<t tx="ekr.20170316113823.49">It can now import demo-it.el.</t>
<t tx="ekr.20170316113823.5">https://groups.google.com/d/msg/leo-editor/RDi2jffWjzI/K-mh4H5QBQAJ

https://github.com/leo-editor/leo-editor/issues/332

The new javascript and perl importers know *nothing* about parsing. They know only about how to scan tokens accurately. The importers copy only entire lines from the text file to Leo nodes. As a result, the new importers much more reliable than previous importers.
</t>
<t tx="ekr.20170316113823.50"></t>
<t tx="ekr.20170316113823.51">Changed LM.openEmptyWorkBook and LM.computeWorkbookFileName.</t>
<t tx="ekr.20170316113823.52">The new code uses the new importer code to clean nodes.</t>
<t tx="ekr.20170316113823.53">- Passing parent=None to ic.createOutline puts the imported node as the last top-level node.
  Changed ic.create_top_node, ic.setDefaultDirectory and undo.createCommonBunch.
  
- g.getEncodingAt now uses a BOM if it exists. No warning is given.

- ic.scanUnknownFileType no longer adds @ignore. No idea why it ever did.
</t>
<t tx="ekr.20170316113823.54">This was an irritating hangnail that affected, for example, the pylint command.</t>
<t tx="ekr.20170316113823.55">g.openUrlOnClick now catches all exception.

More generally, added @g.callback decorator, which does the same.</t>
<t tx="ekr.20170316113823.56">g.findRootsWithPredicate now preserves node order.</t>
<t tx="ekr.20170316113823.57"></t>
<t tx="ekr.20170316113823.58">https://groups.google.com/d/msg/leo-editor/kmj7wQq7qTk/5U9hSTswBQAJ

The singleton g.app.backgroundProcessManager instance of the BackgroundProcessManager (BPM) class handles all details of running separate processes in the background without blocking Leo.

The BPM manages a queue of background processes, and runs them one after another in the background.  It registers a handler with the IdleTimeManager that checks to see if the presently running background process has completed.  If so, it writes its output to the log and starts another background process in the queue.

Because only one background process from the queue is ever running, the background processes can write their output to Leo's log without the output becoming intermixed.

You can kill all processes by calling BPM.kill(). That's what kill-pylint does.  You can add processes to the queue at any time.  For example, you can rerun the pylint command while a background process is running.

The BackgroundProcessManager is completely safe: all of its code runs in the main process.
</t>
<t tx="ekr.20170316113823.59">c.all_roots, c.all_unique_roots, p.nearest_roots, p.nearest_unique_roots (aka p.nearest)

Useful for finding nodes on which to run commands.

def nearest_roots(self, predicate=None):
    '''
    A generator yielding all the root positions "near" p1 = self that
    satisfy the given predicate. p.isAnyAtFileNode is the default
    predicate.
    
    The search first proceeds up the p's tree. If a root is found, this
    generator yields just that root.
    
    Otherwise, the generator yields all nodes in p.subtree() that satisfy
    the predicate. Once a root is found, the generator skips its subtree.
    '''
</t>
<t tx="ekr.20170316113823.6">New in Leo 5.5: optionally colorize doc parts using reStructuredText

Added @bool color-doc-parts-as-rest

The only changes were to match_doc_part and its restarter.
</t>
<t tx="ekr.20170316113823.60">@language rest

Added g.findRootWithPredicate, an important helper. Used it to greatly rst.processTopTree, pyflakes.run, and pylint.run. This improves the rst3 command

Leo's pyflakes and pylint commands can be applied to files that depend on the presently selected node.  They first search down c.p's tree, then up the tree, looking for @&lt;file&gt; nodes.  If no nodes are found, and c.p is a clone, these commands expand the search to the entire tree, looking for an @&lt;file&gt; node that has c.p in its tree.

g.findRootWithPredicate now formalizes and regularizes this search process.  For example:
    
@language python

    def predicate(p):
        return p.isAnyAtFileNode() and p.h.strip().endswith('.py')
       
    roots = g.findRootsWithPredicate(c, root, predicate)
    
@language rest

I added this helper because the rst3 command was not as clever as the pylint and pyflakes commands in this regard.  Now it is. It would have been unbearable to repeat the pylint/pyflakes code one more time...

Here is g.findRootWithPredicate:

@language python

def findRootsWithPredicate(c, root, predicate):
    '''
    Commands often want to find one or more **roots**, given a position p.
    A root is the position of any node matching a predicate.
   
    This function formalizes the search order used by the pylint, pyflakes and
    the rst3 commands, returning a list of zero or more found roots.
    '''
    roots = set()
    # 1. Search p's tree.
    for p in root.self_and_subtree():
        if predicate(p):
            roots.add(p.copy())
    if roots:
        return list(roots)
    # 2. Look up the tree.
    for p in root.parents():
        if predicate(p):
            return [p.copy()]
    # 3. Expand the search if root is a clone.
    clones = []
    for p in root.self_and_parents():
        if p.isCloned():
            clones.append(p.v)
    if clones:
        for p in c.all_positions():
            if predicate(p):
                # Match if any node in p's tree matches any clone.
                for p2 in p.self_and_subtree():
                    if p2.v in clones:
                        return [p.copy()]
    return []</t>
<t tx="ekr.20170316113823.61">https://groups.google.com/d/msg/leo-editor/hJWv-nL-9s0/2QbaGBgtBQAJ

leoApp.py now contains the IdleTimeManager (ITM) class, with a singleton instance, g.app.idleTimeManager. This class handles all details of running code at idle time, including running 'idle' hooks.

The new encapsulation has simplified code all over Leo:

- ITM ivars replace several LeoApp ivars.
- LM.load now calls g.app.idleTimeManager.start() to start idle-time processing, leaving all the details to the ITM class.
- The g.idle time functions in leoGlobals.py now simply set g.app.idle_time_hooks_enabled.
  This is the only other remaining LeoApp ivar pertaining to idle-time processing.
- To schedule code for running at idle time, code calls g.app.idleTimeManager.add_callback(callback).

**Details**

leoApp.py:
- ITM.on_idle now handles idle-hooks.
- Removed g.app.idle_timer.
- 'idle' hooks called if and only if g.app.idle_time_hooks_enabled is True.
- Only one timer is ever started by Leo: g.app.idle_time_manager_timer.
- Removed call to g.enableIdleTimeHook in at the end of LM.doPostPluginsInit.
  It is not needed: g.app.idle_time_hooks_enabled is True initially.
- The enable/disable/toggle-idle-time-events commands now just set g.app.idle_time_hooks_enabled.

leoGlobals.py:
- g.enable/disableIdleTimeHook now just set g.app.idle_time_hooks_enabled.
  They remain for compatibility only.
- g.idleTimeHookHandler is now a stub. It just prints a warning.
  The original has been moved to the attic (leoNotes.txt).
</t>
<t tx="ekr.20170316113823.62">All of Leo's generators yielding positions automatically yield copies of those positions. The following works as expected::

    aList = [p for p in c.all_positions()]

There is no longer any need to do this::

    aList = [p.copy() for p in c.all_positions()]

Of course, copied positions will typically become invalid when the outline changes, so some care is needed.
</t>
<t tx="ekr.20170316113823.63">Fixed a horrible bug in g.handleUrl that opened a file browser by mistake. All tests pass.

- Add g.handleUnl, that can never open a browser.
- g.recursiveUNLSearch selects the desired at idle time.
- sf.find_setting no longer puts up a wonky dialog.
- sf.find_setting calls g.handleUnl instead of g.handleUrl.
- sf.copy_to_my_settings copies the settings tree only if it doesn't exist.
</t>
<t tx="ekr.20170316113823.64">Leo's core code now uses None instead of c.nullPosition(). c.p can be None during startup, which necessitated a few new guards. As a result, the following are all valid tests:

    if not p:        # Correct, pre-Leo 5.5.
    if not p.v:      # Correct, pre-Leo 5.5
    if p is not None # Correct, Leo 5.5 and later.
    if p is None:    # Correct, Leo 5.5 and later.

Now that these tests "just work", there is no need to document them in the scripting tutorial.

Most changed methods are in the startup logic:
    
    *.injectIvars
    c.redraw
    NullTree.edit_widget
    QtStatusLineClass.update
    
And a few others:
    
    c.executeScriptHelper
    EditBodyTestCase.ctor</t>
<t tx="ekr.20170316113823.65">The new code works, and is much simpler than the old.</t>
<t tx="ekr.20170316113823.66">An important simplification of the leoGlobals functions that read files into strings. All tests pass.
    
Most calls to g.readFileIntoString and g.readFileIntoEncodedString contain no keyword args.
    
1. Removed the 'mode' and 'raw' keyword args from g.readFileIntoString.
    g.readFileIntoString is the most important helper.  Simplifying it helps a lot.

2. at.compareFiles calls g.readFileIntoEncodedString instead of g.readFileIntoString(raw=True)

3. Removed  keyword args with default values:
    - leoImport.py:  Removed unnecessary encoding arg from call to readFileIntoString.
    - Removed unnecessary "silent" args in two call to g.readFileIntoEncodedString

</t>
<t tx="ekr.20170316113823.67"></t>
<t tx="ekr.20170316113823.68">Slideshows, screencasts &amp; screenshots

``demo.py``
    Creates slides, screen shots and slide shows, replacing screencast.py, screenshots.py and slideshow.py

User Interface

``bookmarks.py``
    Manages bookmarks using a separate pane.
``dragdropgoodies``
    Dumps files dropped into Leo.
``python_terminal.py``
    Embeds an python interpreter in Leo's log pane.
``QNCalendarWidgets.py``
    Adds a calendar widget.
``richtext.py``
    Enables rich text using the `CKEditor &lt;http://ckeditor.com/&gt;`_ editor.
``settings_finder.py``
    Adds the Edit Settings menu tree to the Settings menu.
``systray.py``
    Adds Leo to the system tray.
``wikiview.py``
    Hides/shows parts of urls in the body editor.
        
Files and nodes

``jinjarender.py``
    Renders @jinja nodes.
``leoOPML.py``
    Read and write .leo files in OPML.
``notebook.py``
    Adds a QML notebook.

Commands and directives

``codewisecompleter.py``
    Uses the ctags database to provide an autocompletion list.
``ctagscompleter.py``
    Uses ctags to provide an autocompletion list.
``ftp.py``
    Supports uploading of files via ftp.
``gitarchive.py``
    Stores snapshots of outline in git.
``leofeeds.py``
    Reads from rss, atom or other sources.
``leomail.py``
    Sync local mailbox files over to Leo.
``markup_inline.py``
    Adds commands that create bold, italic or underlined text.
``nodediff.py``
    Provides commands to run text diffs on node bodies within Leo.
``sftp.py``
    Adds @edit-like functionality for remote files over SFTP.
``threadutil.py``
    Adds utilities for asynchronous operation of commands.
``xml_edit.py``
    Adds commands for importing and exporting xml to and from Leo outlines.</t>
<t tx="ekr.20170316113823.69"></t>
<t tx="ekr.20170316113823.7">https://github.com/leo-editor/leo-editor/issues/371

For example, execute-script will work on the following node:

    @language rest
    Comments...
    @language python
    print('hi')
    @language md
    More comments...
    @language python
    print('abc')

@language rest
The new g.extractExecutableString function removes all lines that are in
the range of @language rest/md/markdown. It truncates the script, with a
warning, if it sees two "executable" @language directives, such as C and
Python.

*Note*: Even if a node contains multiple executable languages, the user can
select a range of lines to execute. All will be well, provided the selected
text contains at most one executable language.
</t>
<t tx="ekr.20170316113823.70">https://github.com/leo-editor/leo-editor/issues/257

</t>
<t tx="ekr.20170316113823.71">https://github.com/leo-editor/leo-editor/pull/349
Command line option to select type of @&lt;file&gt; node to when opening non-outline files</t>
<t tx="ekr.20170316113823.72">The scripting tutorial contains a few more examples before jumping into the details.</t>
<t tx="ekr.20170316113823.73">https://github.com/leo-editor/leo-editor/issues/379

- Removed all abbrev-* commands except abbrev-kill-all and abbrev-list.

- Removed all chapter-* commands except chapter-select and chapter-select-main.
    https://groups.google.com/d/msg/leo-editor/-mv2x_6TAdM/Bgntt7b9AgAJ
    
- Removed all macro-* commands.

- Removed all register-* commands.

- Removed the following commands:
    advertised-undo
    digit-argument
    negative-argument
    number-command
    number-command-0
    ...
    number-command-9
    universal-argument
    
*Note*: Leo 5.4 previously removed all buffer-* and register-* commands.
</t>
<t tx="ekr.20170316113823.74"></t>
<t tx="ekr.20170316113823.75"></t>
<t tx="ekr.20170316113823.76">**Decluttering** replaces @clean, @file, etc. by icons in headlines. This reduces screen space. The setting: `@bool tree-declutter = True` enables decluttering. The setting, `@data tree-declutter-patterns` should contain patterns like::

    # remove @clean and use an icon
    RULE ^@clean (.*)
    REPLACE \1
    ICON file_icons/file_clean.png
    
    # show the last part of long filenames
    RULE ^.{1,1000}([/\\])(.{25})
    REPLACE …\1\2
    
    # if the node name starts with 'peacock node DEMO', make a mess of it
    RULE ^(peacock node DEMO)
    REPLACE LOOK: \1
    ICON Tango/16x16/emotes/face-grin.png
    ICON Tango/16x16/emotes/face-wink.png
    FG @solarized-magenta
    BG white
    FONT Times
    PX 40
    ITALIC 1
    WEIGHT Bold
</t>
<t tx="ekr.20170316113823.77">Here's the commit message for 05df9ac

add @cmd justify-toggle-auto and @bool autojustify-on-at-start

The @int autojustify behavior is very useful for writing prose
(not code) when you want text wrapped at a particular column with
a real newline, not just visually wrapped at the window edge. To
be usable it needs a command to toggle activation, and a setting
to decide whether it's on by default, this commit adds those.

The setting @int autojustify itself has been around for a while,
I'd forgotten about it, I've been wanting this feature for years,
made a failed attempt to add it once, but just (re)discovered the
when I realized how it should be done, and found that it already
was :-)

More discussion here:
https://github.com/leo-editor/leo-editor/issues/14</t>
<t tx="ekr.20170316113823.78">Thanks to Tsuchi Noko for these.</t>
<t tx="ekr.20170316113823.79">It opens leo/config/themes.leo.
</t>
<t tx="ekr.20170316113823.8">https://github.com/leo-editor/leo-editor/issues/334
This was a large project.  See the issue tracker for extensive notes.

Full documentation is here:
https://github.com/leo-editor/leo-editor/blob/master/leo/doc/importers.md

New, line-oriented scanning code in leo/importers/linescanner.py replaces
old, character-oriented, code in leo/importers/basescanner.py.

The xml and html importers now *regularize* whitespace. xml and html are outliers because they have neither explicit brackets nor strict indentation rules.
</t>
<t tx="ekr.20170316113823.80">See The "What's new in this file" node in scripts.leo for details.</t>
<t tx="ekr.20170316113823.81"></t>
<t tx="ekr.20170316113823.82"></t>
<t tx="ekr.20170316113823.83">Ctrl-click on UNL's goes to the UNL. This already existed, as an Easter Egg for file:// url's.

leoSettings.leo:
- Added two new patterns to @data wikiview-link-patterns.

leoColorizer.py:
- Added jedit.match_unl.
- Added support for unl's at end of jedit.colorRangeWithTag.

leoGlobals.py:
- g.recursiveUNLSearch expands found node if it has children.
- g.handleUnl looks for files in various places.
- g.openUrlHelper adds support for UNLs.

wikiview.py:
- Added a unl linking to the plugins settings. So cool.
</t>
<t tx="ekr.20170316113823.84"></t>
<t tx="ekr.20170316113823.85">The leomail plugin reads .mbox mail archive files into a tree of Leo nodes. This saves a lot of work.

Google "&lt;your favorite mail client&gt; archive to mbox" for instructions on generating .mbox files.

The new code contains the following improvements:

1. It works with both Python 2 and 3. The old code could corrupt .leo files by including strings that the sax parser barfed on. The new code appears safe to use. The conversion involved tricky details in libraries, as well as the usual cursed bytes/string/unicode issues.

2. The new code organizes messages by threads.  Messages that start with "re:" become children of the node that started the thread.

3. Better warning and informational messages, and a better docstring.</t>
<t tx="ekr.20170316113823.86">https://groups.google.com/d/msg/leo-editor/8moMUEOOgWA/HE0cl-aADQAJ

Leo's markdown importer converts all sections to use '#' markup. The technical justification appears at the bottom of the page for #342. The rest of this post explains the change from a user's point of view.

tl;dr: Converting all sections to '#' markup is Leonine, simplest and best. Only existing .md files that Leo didn't write could be changed.  If such changes don't work for you, just insert @ignore yourself when git or diff reports differences.

Imo, this change is fully justified:

1. It is more Leonine.

When creating and changing .md files from within Leo, @auto-md works much more smoothly.  Indeed, as I have just verified, converting an @nosent x.md file to @auto-md x.md "just works".

There is absolutely no reason to use underlined sections when using Leo.  The headlines proclaim the section structure far better than flat text of any kind, whether ### section name or underlined section names.

2. Perfect import check should not wag the dog.

The markdown importer is one of the simplest of all.  The possibility of dropping data seems remote.  Requiring a typical perfect import check to pass would preclude regularizing section markup.  It's just that simple.

Furthermore, the existing unit tests for the markup importer do check imported section structure, albeit imperfectly That should suffice for now. In the unlikely event that real problems are reported, these after-the-fact unit tests can be improved.

**Summary**

Importing markdown files containing underlined sections could only pass typical perfect import checks if existing underlining were somehow retained.  That's a bad idea.  Instead, Leo's markdown importer now implicitly converts all sections to '#' markup.  In essence, the markup disappears from the outline, to be automagically reinserted when Leo writes the outline.

This new scheme can change existing .md files, but only files that Leo didn't write.  If that is inconvenient for you, just add @ignore yourself.
</t>
<t tx="ekr.20170316113823.87">https://groups.google.com/d/msg/leo-editor/L4EAfY7NJbw/NgSv5zSDEwAJ

This is buggy.
</t>
<t tx="ekr.20170316113823.88">Settings:

- @bool autojustify-on-at-start
- @bool color-doc-parts-as-rest
- @bool run-pyflakes-on-write
- @bool tree-declutter = True
- @data tree-declutter-patterns

Command-line options::

    --load-type=LOAD_TYPE
    --fail-fast             # sets failfast option in unit tests.
</t>
<t tx="ekr.20170316113823.9">Leo no longer hangs waiting for this command to finish.
https://github.com/leo-editor/leo-editor/issues/328
</t>
<t tx="ekr.20170911061827.1">'''Make sure no distributed .leo file contains xml-stylesheet elements.'''
# g.cls()
&lt;&lt; define files &gt;&gt;
for fn in files:
    path = g.os_path_finalize_join(g.app.loadDir, '..', fn)
    if g.os_path_exists(path):
        with open(path, 'rb') as f:
            s = f.read()
        s = g.toUnicode(s)
        if s.find('&lt;xml-stylesheet') &gt; -1:
            print('contains xml-stylesheet element: %s' % (path))
    else:
        print('does not exist: %s' % path)
print('done')
</t>
<t tx="ekr.20170911062209.1">files = (
    'config/exampleSettings.leo',
    'config/leoSettings.leo',
    'core/leoPyRef.leo',
    'dist/leoDist.leo',
    'doc/LeoReleaseNotes.leo',
    'doc/cheatSheet.leo',
    'doc/default_workbook.leo',
    'doc/leoDocs.leo',
    'doc/leoSlideShows.leo',
    'doc/quickstart.leo',
    'external/leo2html.leo',
    'plugins/leoGuiPluginsRef.leo',
    'plugins/leoPluginsRef.leo',
    'scripts/scripts.leo',
    'test/test.leo',
)</t>
<t tx="ekr.20170911085243.1">Leo 5.6 September 25, 2017

[Leo](http://leoeditor.com/) 5.6 is now available on [SourceForge](http://sourceforge.net/projects/leo/files/Leo/) and on [GitHub](https://github.com/leo-editor/leo-editor).

Leo is an IDE, outliner and PIM, as described [here](http://leoeditor.com/preface.html).

Simulating Leo's features in Vim, Emacs or Eclipse is possible, just as it is possible to simulate Python in assembly language...

**The highlights of Leo 5.6**

- The cursesGui2.py plugin creates a console gui for Leo.
- Added "Yes to All" and "No to All" buttons to file-changed dialog.
- Improved how Leo switches between git branches.
- Created outline-oriented git-diff command.

**Links**

- [Leo's home page](http://leoeditor.com)
- [Documentation](http://leoeditor.com/leo_toc.html)
- [Tutorials](http://leoeditor.com/tutorial.html)
- [Video tutorials](http://leoeditor.com/screencasts.html)
- [Forum](http://groups.google.com/group/leo-editor)
- [Download](http://sourceforge.net/projects/leo/files/)
- [Leo on GitHub](https://github.com/leo-editor/leo-editor)
- [What people are saying about Leo](http://leoeditor.com/testimonials.html)
- [A web page that displays .leo files](http://leoeditor.com/load-leo.html)
- [More links](http://leoeditor.com/leoLinks.html)
</t>
<t tx="ekr.20180124100848.1">c:\Test\LeoAppFolder&gt;LeoApp.exe


reading settings in C:\Users\edreamleo\.leo\workbook.leo
reading settings in C:\Test\LEOAPP~1\leo\test\unitTest.leo
reading: @file unitTestStartup.txt
reading: @file activeUnitTests.txt
.saved: save-new-test.py
....
Traceback (most recent call last):
  File "launchLeo.py", line 8, in &lt;module&gt;
  File "leo\core\runLeo.py", line 71, in run
    g.app.loadManager.load(fileName, pymacs)
  File "leo\core\leoApp.py", line 2117, in load
    ok = lm.doPostPluginsInit()
  File "leo\core\leoApp.py", line 2722, in doPostPluginsInit
    c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
  File "leo\core\leoApp.py", line 2959, in loadLocalFile
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
  File "leo\core\leoApp.py", line 3007, in openFileByName
    lm.initWrapperLeoFile(c, fn)
  File "leo\core\leoApp.py", line 3084, in initWrapperLeoFile
    p.h = g.shortFileName(fn) if fn.endswith('.leo') else '@edit %s' % fn
AttributeError: 'NoneType' object has no attribute 'h'
Failed to execute script launchLeo
F...................test of at.printError: La Pe?a
..............s...........................
End of leoAtFile tests
..........s...
c:\Test\LeoAppFolder&gt;python2 C:\Test\LEOAPP~1\leo\test\leo-bridge-test.py

c:\Test\LeoAppFolder&gt;c:\Anaconda2\python.exe C:\Test\LEOAPP~1\leo\test\leo-bridge-test.py
.ssss........................................
End of leoColor tests
................................
End of leoCommands tests
........
End of leoConfig tests
....ss...................................
.........................................................................................................................................s...........................
End of typing tests
.
End of leoEditCommands tests.
............
End of leoFileCommands tests.
.....
End of leoFind tests.
.............
End of leoFrame tests.
..........................F.............................................
End of leoGlobals tests.
...
End of leoGui tests.
...............................................................................................................................
End of leoImport tests.
..s....
End of leoKeys tests.
.........................................
End of leoNodes tests.
................................s..................................................................
End of leoUndo tests.
...............................................................................................................................................................
End of plugins unit tests
.@test print redraw count: 736
..all unit tests done
..
======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test batch mode

----------------------------------------------------------------------
Traceback (most recent call last):
  File "leo\core\leoTest.py", line 211, in runTest
    builtins.execfile(scriptFile, d)
  File "C:\Test\LEOAPP~1\leo\test\scriptFile.py", line 38, in &lt;module&gt;
    assert(g.os_path_exists(test_file))
AssertionError

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test g.importModule

----------------------------------------------------------------------
Traceback (most recent call last):
  File "leo\core\leoTest.py", line 211, in runTest
    builtins.execfile(scriptFile, d)
  File "C:\Test\LEOAPP~1\leo\test\scriptFile.py", line 5, in &lt;module&gt;
    assert g.importModule('rope',verbose=False)
AssertionError

----------------------------------------------------------------------
Ran 916 tests in 123.577s

FAILED (failures=2, skipped=11)

c:\Test\LeoAppFolder&gt;

##### can not open @edit C:\Test\LEOAPP~1\README.MD</t>
<t tx="ekr.20180212094405.1">Leo 5.7 final February 26, 2018

Leo 5.7 final, http://leoeditor.com, is now available on [SourceForge](http://sourceforge.net/projects/leo/files/Leo/) and on [GitHub](https://github.com/leo-editor/leo-editor).

Leo is an IDE, outliner and PIM, as described [here](http://leoeditor.com/preface.html).

Simulating Leo's features in Vim, Emacs or Eclipse is possible, just as it is possible to simulate Python in C or assembly language...

**The highlights of Leo 5.7**

- pip install leo.
- A debian package for Leo.
- A web-based Leo Viewer, written by Joe Orr.
- Added diff-leo-files and diff-and-open-leo-files commands.
  These create outline-oriented diffs for .leo files.
- New reload-settings command.
- Leo optionally shows user tips on startup.
- Added a new Tips page to Leo's documentation.
- A visual widget for editing cvs tables.
- Spell checking works without pyenchant
- Improved the console_gui plugin.
- Added live links from urls in the log pane.
- Unit tests use a string gui, making them faster and more robust.
- The line_numbering plugin shows line numbers in external files.
- Improved the javascript importer.
- Added a TreePad importer.
- Added 6 new commands.
- Dozens of bug fixes.

**Links**

- Leo's home page: http://leoeditor.com
- [Documentation](http://leoeditor.com/leo_toc.html)
- [Tutorials](http://leoeditor.com/tutorial.html)
- [Video tutorials](http://leoeditor.com/screencasts.html)
- [Forum](http://groups.google.com/group/leo-editor)
- [Download](http://sourceforge.net/projects/leo/files/)
- [Leo on GitHub](https://github.com/leo-editor/leo-editor)
- [LeoVue](https://github.com/kaleguy/leovue#leo-vue)
- [What people are saying about Leo](http://leoeditor.com/testimonials.html)
- [A web page that displays .leo files](http://leoeditor.com/load-leo.html)
- [More links](http://leoeditor.com/leoLinks.html)
</t>
<t tx="maphew.20171107045903.1">Leo 5.6 September 25, 2017

[Leo](http://leoeditor.com/) 5.6 is now available on [SourceForge](http://sourceforge.net/projects/leo/files/Leo/) and on [GitHub](https://github.com/leo-editor/leo-editor).

Leo is an IDE, outliner and PIM, as described [here](http://leoeditor.com/preface.html).

Simulating Leo's features in Vim, Emacs or Eclipse is possible, just as it is possible to simulate Python in assembly language...

**The highlights of Leo 5.6**

- The cursesGui2.py plugin creates a console gui for Leo.
- Added "Yes to All" and "No to All" buttons to file-changed dialog.
- Improved how Leo switches between git branches.
- Created outline-oriented git-diff command.

**Leo 5.6.1, November 9, 2017**

- Published on Python Package Index (PyPi) and pip installable, `pip install leo`

**Links**

- [Leo's home page](http://leoeditor.com)
- [Documentation](http://leoeditor.com/leo_toc.html)
- [Tutorials](http://leoeditor.com/tutorial.html)
- [Video tutorials](http://leoeditor.com/screencasts.html)
- [Forum](http://groups.google.com/group/leo-editor)
- [Download](http://sourceforge.net/projects/leo/files/)
- [Leo on GitHub](https://github.com/leo-editor/leo-editor)
- [What people are saying about Leo](http://leoeditor.com/testimonials.html)
- [A web page that displays .leo files](http://leoeditor.com/load-leo.html)
- [More links](http://leoeditor.com/leoLinks.html)
</t>
<t tx="maphew.20180128212042.1">@language md
@wrap

Written by Matt Wilkie. Slightly revised by EKR.

PyPi is the Python Package Index Page: https://pypi.python.org/pypi

See https://github.com/leo-editor/leo-editor/issues/562

Once published to pypi Leo can be installed with:

    pip install leo

Python 2.7 will need to install PyQt 4 or 5 as a separate step. Anaconda or
miniconda is recommended:

    conda install pyqt

Developers should install from git as some files are left out when using pip (see Caveats):

    git clone --depth=500 https://github.com/leo-editor/leo-editor.git
    pip install -e .\leo-editor

nb: Optional `--depth=500` fetches the last 3-4 months of activity and is
    orders of magnitude faster than a full clone. If needed later use `git pull
    --unshallow` to grab everything that was missed.
</t>
<t tx="maphew.20180128212042.2">Install using pip if needed:

 - Wheel: for building cross platform binaries (might be installed already)
 - Setuptools: because ...setup!
 - Twine: for secure upload to pypi.org
 - PyPandoc: to convert markdown to rst for Readme.

    pip install pypandoc setuptools twine wheel

Pandoc executable must be in PATH. If not installed already one these should
work (or use your own preferred method):

    # Preferred
    conda install pandoc

    # Alternate
    from pypandoc.pandoc_download import download_pandoc
    download_pandoc()</t>
<t tx="maphew.20180128212042.3">A PyPi account is needed to update Leo's pypi reference. Contact one of the
package index owners to be added as a maintainer if needed. See end of
https://pypi.python.org/pypi/leo

Verify access Leo package edit page at:
https://pypi.python.org/pypi?%3Aaction=pkg_edit&amp;name=leo
</t>
<t tx="maphew.20180128212042.4">## Overview

* Remove stale distribution files &amp; folders.  
* Optionally set local checkout to specific version tag.  
* Build redistributable source and binary wheel package.  
* Upload to PyPi (assumes account registration already completed).  
* Test download and install from PyPi. Best to uninstall old Leo first or run in clean virtual env.

## Example

Windows syntax. 'Activate/deactivate' assume using virtual environments; skip those lines if not:

    activate leo-build
    
    rmdir /s/q dist build leo.egg-info
    git checkout tags/5.7
    python setup.py bdist_wheel
    
    :: Optional, test install locally
    pip install dist\*.whl
    leo-console --version
    pip uninstall leo
    
    twine upload https://pypi.org/legacy/ dist\*.whl
    
    :: Optional, inspect public page for problems
    start https://pypi.python.org/pypi/leo
    
    deactivate
    activate py3-clean
    
    pip install leo
    leo-console --version

Twine upload will use username and password stored in `.pypirc`, or will prompt
if that doesn't exist.</t>
<t tx="maphew.20180128212042.5">`pip install leo` only installs the contents of `leo` folder.
So links to files in the project root or other folders will be broken. (Background https://github.com/leo-editor/leo-editor/issues/573)

    ./leo-editor/*         --&gt; left out
    ./leo-editor/docs/*    --&gt; left out
    ./leo-editor/leo/*/*/* --&gt; PYTHONHOME/Lib/site-packages/leo

Docs: of little concern. These can regenerated from sources in ./leo (leoDocs.leo), and are on the website: http://leoeditor.com

Root: these files should only be involved in building installers and similar activities (e.g. leoDist.leo). Work from a git checkout or source tarball instead: https://github.com/leo-editor/leo-editor</t>
<t tx="maphew.20180128213245.1">TestPyPI: https://packaging.python.org/guides/using-testpypi/
is a separate instance of the Python Package Index (PyPI) that allows
trying out the distribution tools and process without worrying about affecting
the real index.

I (Matt) don't recommend using Test PyPi for Leo unless problems with the
package on the PyPi side are anticipated. It's too much of a pain to switch back
and forth between test and production when testing installs. In practice most
problems will be found and encountered when testing an install straight from the
whl file on disk:

    pip install dist\Leo-*.whl

That said, here's my recipe for packaging a new release for Test PyPi:
(Windows syntax)

    ::Verify integrity and Build (see leo\dist\build-*.bat)
    python setup.py check
    python setup.py bdist_wheel

    ::Test default install locally
    pip install dist\leo-5.7.dev344-py2.py3-none-any.whl
    leo-c --version
    pip uninstall leo

    ::Upload
    twine upload --repository-url https://test.pypi.org/legacy/ dist/leo-5.7.dev344-py2.py3-none-any

    ::Install from remote
    pip install --pre --index-url https://test.pypi.org/simple/ leo
    leo-c --version

Remove broken releases (still can't re-use identical version numbers and file names though):
https://testpypi.python.org/pypi?%3Aaction=pkg_edit&amp;name=leo
</t>
</tnodes>
</leo_file>
